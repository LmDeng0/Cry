{"source": "github_chisel", "task": "impl_from_spec", "operator": "RegTesterMod", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "RegTesterMod", "io": {"inputs": [{"name": "in", "type": "Vec", "chisel_type": "Vec", "width": "vecSize, UInt()"}], "outputs": [{"name": "out", "type": "Vec", "chisel_type": "Vec", "width": "vecSize, UInt()"}]}}}, "output": {"code_after": "    class RegTesterMod(vecSize: Int) extends Module {\n      val io = IO(new Bundle {\n        val in = Input(Vec(vecSize, UInt()))\n        val out = Output(Vec(vecSize, UInt()))\n      })\n      val vecReg = RegNext(io.in, VecInit(Seq.fill(vecSize) { 0.U }))\n      io.out := vecReg\n    }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "DetectTwoOnes", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "cookbook", "module": "DetectTwoOnes", "io": {"inputs": [{"name": "in", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "out", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class DetectTwoOnes extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(Bool())\n  })\n\n  object State extends ChiselEnum {\n    val sNone, sOne1, sTwo1s = Value\n  }\n\n  val state = RegInit(State.sNone)\n\n  io.out := (state === State.sTwo1s)\n\n  switch(state) {\n    is(State.sNone) {\n      when(io.in) {\n        state := State.sOne1\n      }\n    }\n    is(State.sOne1) {\n      when(io.in) {\n        state := State.sTwo1s\n      }.otherwise {\n        state := State.sNone\n      }\n    }\n    is(State.sTwo1s) {\n      when(!io.in) {\n        state := State.sNone\n      }\n    }\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "Foo", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chisel3.util.experimental.decode", "module": "Foo", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "4.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}]}}}, "output": {"code_after": "    class Foo extends Module {\n\n      val io = IO(new Bundle {\n        val in = Input(UInt(4.W))\n        val out = Output(UInt(16.W))\n      })\n\n      val table = TruthTable(\n        (0 until 16).map { i =>\n          BitPat(i.U(4.W)) -> BitPat((1 << i).U(16.W))\n        },\n        BitPat.dontCare(16)\n      )\n\n      io.out := decoder.qmc(io.in, table)\n    }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ModuleWithoutDontCare", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ModuleWithoutDontCare", "io": {"inputs": [], "outputs": [{"name": "outs", "type": "Vec", "chisel_type": "Vec", "width": "nElements, Bool()"}]}}}, "output": {"code_after": "    class ModuleWithoutDontCare extends Module {\n      val io = IO(new Bundle {\n        val outs = Output(Vec(nElements, Bool()))\n      })\n      io.outs <> DontCare\n    }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ModuleWithoutDontCare", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ModuleWithoutDontCare", "io": {"inputs": [{"name": "ins", "type": "Vec", "chisel_type": "Vec", "width": "nElements, Bool()"}], "outputs": []}}}, "output": {"code_after": "    class ModuleWithoutDontCare extends Module {\n      val io = IO(new Bundle {\n        val ins = Input(Vec(nElements, Bool()))\n      })\n      io.ins := DontCare\n    }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ModuleWithIncompleteAssignment", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ModuleWithIncompleteAssignment", "io": {"inputs": [], "outputs": [{"name": "out", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "    class ModuleWithIncompleteAssignment extends Module {\n      val io = IO(new Bundle {\n        val out = Output(Bool())\n      })\n      val counter = Counter(8)\n      when(counter.inc()) {\n        io.out := true.B\n      }\n    }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ModuleWithUnconditionalAssignment", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ModuleWithUnconditionalAssignment", "io": {"inputs": [], "outputs": [{"name": "out", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "    class ModuleWithUnconditionalAssignment extends Module {\n      val io = IO(new Bundle {\n        val out = Output(Bool())\n      })\n      val counter = Counter(8)\n      io.out := false.B\n      when(counter.inc()) {\n        io.out := true.B\n      }\n    }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ModuleWithConditionalAndOtherwiseAssignment", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ModuleWithConditionalAndOtherwiseAssignment", "io": {"inputs": [], "outputs": [{"name": "out", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "    class ModuleWithConditionalAndOtherwiseAssignment extends Module {\n      val io = IO(new Bundle {\n        val out = Output(Bool())\n      })\n      val counter = Counter(8)\n      when(counter.inc()) {\n        io.out := true.B\n      }.otherwise {\n        io.out := false.B\n      }\n    }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ModuleVec", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ModuleVec", "io": {"inputs": [{"name": "ins", "type": "Vec", "chisel_type": "Vec", "width": "n, UInt(32.W)"}], "outputs": [{"name": "outs", "type": "Vec", "chisel_type": "Vec", "width": "n, UInt(32.W)"}]}}}, "output": {"code_after": "class ModuleVec(val n: Int) extends Module {\n  val io = IO(new Bundle {\n    val ins = Input(Vec(n, UInt(32.W)))\n    val outs = Output(Vec(n, UInt(32.W)))\n  })\n  val pluses = VecInit(Seq.fill(n) { Module(new PlusOne).io })\n  for (i <- 0 until n) {\n    pluses(i).in := io.ins(i)\n    io.outs(i) := pluses(i).out\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ModuleWhen", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ModuleWhen", "io": {"inputs": [], "outputs": [{"name": "en", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class ModuleWhen extends Module {\n  val io = IO(new Bundle {\n    val s = new SimpleIO\n    val en = Output(Bool())\n  })\n  when(io.en) {\n    val inc = Module(new PlusOne).io\n    inc.in := io.s.in\n    io.s.out := inc.out\n  }.otherwise { io.s.out := io.s.in }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "MyModule", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "MyModule", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}], "outputs": [{"name": "out", "type": "Vec", "chisel_type": "Vec", "width": "2, UInt(8.W)"}]}}}, "output": {"code_after": "    class MyModule extends Module {\n      val io = IO(new Bundle {\n        val in = Input(UInt(8.W))\n        val out = Output(Vec(2, UInt(8.W)))\n      })\n      val extra = IO(Input(UInt(8.W)))\n      val delay = RegNext(io.in)\n      io.out(0) := delay\n      io.out(1) := delay + extra\n    }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "MyModule", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "MyModule", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}], "outputs": [{"name": "out", "type": "Vec", "chisel_type": "Vec", "width": "2, UInt(8.W)"}]}}}, "output": {"code_after": "    class MyModule extends Module {\n      val io = IO(new Bundle {\n        val in = Input(UInt(8.W))\n        val out = Output(Vec(2, UInt(8.W)))\n      })\n      val extra = IO(Input(UInt(8.W)))\n      val delay = RegNext(io.in)\n      io.out(0) := delay\n      io.out(1) := delay + extra\n    }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "Foo", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "Foo", "io": {"inputs": [{"name": "inMono", "type": "MixedVec", "chisel_type": "MixedVec", "width": "Seq(UInt(8.W), UInt(16.W), UInt(4.W), UInt(7.W))"}], "outputs": []}}}, "output": {"code_after": "    class Foo extends Module {\n      val io = IO(new Bundle {\n        val inMono = Input(MixedVec(Seq(UInt(8.W), UInt(16.W), UInt(4.W), UInt(7.W))))\n      })\n      val foo: Seq[UInt] = io.inMono\n    }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "GCD", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "GCD", "io": {"inputs": [{"name": "a", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "b", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "e", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "z", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "v", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class GCD extends Module {\n  val io = IO(new Bundle {\n    val a = Input(UInt(32.W))\n    val b = Input(UInt(32.W))\n    val e = Input(Bool())\n    val z = Output(UInt(32.W))\n    val v = Output(Bool())\n  })\n  val x = Reg(UInt(32.W))\n  val y = Reg(UInt(32.W))\n  when(x > y) { x := x -% y }.otherwise { y := y -% x }\n  when(io.e) { x := io.a; y := io.b }\n  io.z := x\n  io.v := y === 0.U\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "MyModule", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "MyModule", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}]}}}, "output": {"code_after": "    class MyModule(n: Int) extends Module {\n      val io = IO(new Bundle {\n        val in = Input(UInt(8.W))\n        val out = Output(UInt(8.W))\n        if (n > 4) {\n          println(\"Here we are!\")\n        }\n      })\n      io.out := io.in\n    }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "Decoder", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "Decoder", "io": {"inputs": [{"name": "inst", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}], "outputs": [{"name": "matched", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class Decoder(bitpats: List[String]) extends Module {\n  val io = IO(new Bundle {\n    val inst = Input(UInt(32.W))\n    val matched = Output(Bool())\n  })\n  io.matched := VecInit(bitpats.map(BitPat(_) === io.inst)).reduce(_ || _)\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "Top", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "Top", "io": {"inputs": [{"name": "enable", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "write", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "addr", "type": "UInt", "chisel_type": "UInt", "width": "10.W"}, {"name": "dataIn", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}], "outputs": [{"name": "dataOut", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}]}}}, "output": {"code_after": "    class Top extends Module {\n      val io = IO(new Bundle {\n        val enable = Input(Bool())\n        val write = Input(Bool())\n        val addr = Input(UInt(10.W))\n        val dataIn = Input(UInt(8.W))\n        val dataOut = Output(UInt(8.W))\n      })\n\n      val smem = withModulePrefix(\"Foo\") {\n        SyncReadMem(1024, UInt(8.W))\n      }\n\n      val cmem = withModulePrefix(\"Bar\") {\n        Mem(1024, UInt(8.W))\n      }\n\n      val sram = withModulePrefix(\"Baz\") {\n        SRAM(1024, UInt(8.W), 1, 1, 0)\n      }\n\n      smem.write(io.addr, io.dataIn)\n      io.dataOut := smem.read(io.addr, io.enable)\n    }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "PlusOneModule", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "PlusOneModule", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}]}}}, "output": {"code_after": "class PlusOneModule extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  io.out := io.in + 1.asUInt\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "Risc", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "Risc", "io": {"inputs": [{"name": "isWr", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "wrAddr", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}, {"name": "wrData", "type": "Bits", "chisel_type": "Bits", "width": "32.W"}, {"name": "boot", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "valid", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "out", "type": "Bits", "chisel_type": "Bits", "width": "32.W"}]}}}, "output": {"code_after": "class Risc extends Module {\n  val io = IO(new Bundle {\n    val isWr = Input(Bool())\n    val wrAddr = Input(UInt(8.W))\n    val wrData = Input(Bits(32.W))\n    val boot = Input(Bool())\n    val valid = Output(Bool())\n    val out = Output(Bits(32.W))\n  })\n  val memSize = 256\n  val file = Mem(memSize, Bits(32.W))\n  val code = Mem(memSize, Bits(32.W))\n  val pc = RegInit(0.U(8.W))\n\n  val add_op :: imm_op :: Nil = Enum(2)\n\n  val inst = code(pc)\n  val op = inst(31, 24)\n  val rci = inst(23, 16)\n  val rai = inst(15, 8)\n  val rbi = inst(7, 0)\n\n  val ra = Mux(rai === 0.U, 0.U, file(rai))\n  val rb = Mux(rbi === 0.U, 0.U, file(rbi))\n  val rc = Wire(Bits(32.W))\n\n  io.valid := false.B\n  io.out := 0.U\n  rc := 0.U\n\n  when(io.isWr) {\n    code(io.wrAddr) := io.wrData\n  }.elsewhen(io.boot) {\n    pc := 0.U\n  }.otherwise {\n    switch(op) {\n      is(add_op) { rc := ra +% rb }\n      is(imm_op) { rc := (rai << 8) | rbi }\n    }\n    io.out := rc\n    when(rci === 255.U) {\n      io.valid := true.B\n    }.otherwise {\n      file(rci) := rc\n    }\n    pc := pc +% 1.U\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "DirectionHaver", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "DirectionHaver", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}]}}}, "output": {"code_after": "class DirectionHaver extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n    val inBundle = Input(new DirectionedBundle) // should override elements\n    val outBundle = Output(new DirectionedBundle) // should override elements\n  })\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "HasDeadCodeChild", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "HasDeadCodeChild", "io": {"inputs": [{"name": "a", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}], "outputs": [{"name": "b", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "c", "type": "Vec", "chisel_type": "Vec", "width": "2, UInt(32.W)"}]}}}, "output": {"code_after": "class HasDeadCodeChild(withDontTouch: Boolean) extends Module {\n  val io = IO(new Bundle {\n    val a = Input(UInt(32.W))\n    val b = Output(UInt(32.W))\n    val c = Output(Vec(2, UInt(32.W)))\n  })\n  io.b := io.a\n  io.c := DontCare\n  if (withDontTouch) {\n    dontTouch(io.c)\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "HasDeadCode", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "HasDeadCode", "io": {"inputs": [{"name": "a", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}], "outputs": [{"name": "b", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}]}}}, "output": {"code_after": "class HasDeadCode(withDontTouch: Boolean) extends Module {\n  val io = IO(new Bundle {\n    val a = Input(UInt(32.W))\n    val b = Output(UInt(32.W))\n  })\n  val inst = Module(new HasDeadCodeChild(withDontTouch))\n  inst.io.a := io.a\n  io.b := inst.io.b\n  val dead = WireDefault(io.a + 1.U)\n  if (withDontTouch) {\n    dontTouch(dead)\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "HasDeadCodeLeaves", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "HasDeadCodeLeaves", "io": {"inputs": [{"name": "a", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}], "outputs": [{"name": "b", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}]}}}, "output": {"code_after": "class HasDeadCodeLeaves() extends Module {\n  val io = IO(new Bundle {\n    val a = Input(UInt(32.W))\n    val b = Output(UInt(32.W))\n  })\n  val inst = Module(new HasDeadCodeChildLeaves())\n  inst.io.a.a1 := io.a\n  inst.io.a.a2 := io.a\n  val tmp = inst.io.b.b1 + inst.io.b.b2\n  dontTouch(tmp)\n  io.b := tmp\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "HasProbesAndProperties", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "HasProbesAndProperties", "io": {"inputs": [], "outputs": [{"name": "a", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "probe", "type": "Probe", "chisel_type": "Probe", "width": "UInt(32.W)"}]}}}, "output": {"code_after": "class HasProbesAndProperties() extends Module {\n  val io = IO(new Bundle {\n    val a = Output(UInt(32.W))\n    val probe = Output(Probe(UInt(32.W)))\n    val prop = Output(Property[Int]())\n  })\n  io.a := DontCare\n  io.probe := probe.ProbeValue(io.a)\n  io.prop := Property(5)\n\n  dontTouch(io)\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "MemorySearch", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "MemorySearch", "io": {"inputs": [{"name": "target", "type": "UInt", "chisel_type": "UInt", "width": "4.W"}, {"name": "en", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "done", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "address", "type": "UInt", "chisel_type": "UInt", "width": "3.W"}]}}}, "output": {"code_after": "class MemorySearch extends Module {\n  val io = IO(new Bundle {\n    val target = Input(UInt(4.W))\n    val en = Input(Bool())\n    val done = Output(Bool())\n    val address = Output(UInt(3.W))\n  })\n  val vals = Array(0, 4, 15, 14, 2, 5, 13)\n  val index = RegInit(0.U(3.W))\n  val elts = VecInit(vals.toIndexedSeq.map(_.asUInt(4.W)))\n  // val elts  = Mem(UInt(32.W), 8) TODO ????\n  val elt = elts(index)\n  val end = !io.en && ((elt === io.target) || (index === 7.U))\n  when(io.en) {\n    index := 0.U\n  }.elsewhen(!end) {\n    index := index +% 1.U\n  }\n  io.done := end\n  io.address := index\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "SimpleTest", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "SimpleTest", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}]}}}, "output": {"code_after": "class SimpleTest extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  io.out := io.in\n  cover(io.in === 3.U)\n  when(io.in === 3.U) {\n    assume(io.in =/= 2.U)\n    assert(io.out === io.in, p\"${FullName(io.in)}:${io.in} is equal to ${FullName(io.out)}:${io.out}\")\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "LabelTest", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "LabelTest", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}]}}}, "output": {"code_after": "    class LabelTest extends Module {\n      val io = IO(new Bundle {\n        val in = Input(UInt(8.W))\n        val out = Output(UInt(8.W))\n      })\n      io.out := io.in\n      layer.elideBlocks {\n        val cov = cover(io.in === 3.U)\n        val assm = chisel3.assume(io.in =/= 2.U)\n        val asst = chisel3.assert(io.out === io.in)\n      }\n    }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "Padder", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "Padder", "io": {"inputs": [{"name": "a", "type": "UInt", "chisel_type": "UInt", "width": "4.W"}], "outputs": [{"name": "asp", "type": "SInt", "chisel_type": "SInt", "width": "8.W"}, {"name": "aup", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}]}}}, "output": {"code_after": "class Padder extends Module {\n  val io = IO(new Bundle {\n    val a = Input(UInt(4.W))\n    val asp = Output(SInt(8.W))\n    val aup = Output(UInt(8.W))\n  })\n  io.asp := io.a.asSInt\n  io.aup := io.a.asUInt\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ParameterizedOneHot", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ParameterizedOneHot", "io": {"inputs": [{"name": "selectors", "type": "Vec", "chisel_type": "Vec", "width": "4, Bool()"}], "outputs": []}}}, "output": {"code_after": "class ParameterizedOneHot[T <: Data](values: Seq[T], outGen: T) extends Module {\n  val io = IO(new Bundle {\n    val selectors = Input(Vec(4, Bool()))\n    val out = Output(outGen)\n  })\n\n  val terms = io.selectors.zip(values)\n  io.out := Mux1H(terms)\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ParameterizedAggregateOneHot", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ParameterizedAggregateOneHot", "io": {"inputs": [{"name": "selectors", "type": "Vec", "chisel_type": "Vec", "width": "4, Bool()"}], "outputs": []}}}, "output": {"code_after": "class ParameterizedAggregateOneHot[T <: Data](valGen: HasMakeLit[T], outGen: T) extends Module {\n  val io = IO(new Bundle {\n    val selectors = Input(Vec(4, Bool()))\n    val out = Output(outGen)\n  })\n\n  val values = (0 until 4).map { n => valGen.makeLit(n) }\n  val terms = io.selectors.zip(values)\n  io.out := Mux1H(terms)\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "TestModule", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "TestModule", "io": {"inputs": [{"name": "rdEnable", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "writeData", "type": "UInt", "chisel_type": "UInt", "width": "2.W"}, {"name": "mrwWriteData", "type": "Vec", "chisel_type": "Vec", "width": "2, UInt(2.W)"}, {"name": "mrwWriteMask", "type": "Vec", "chisel_type": "Vec", "width": "2, Bool()"}, {"name": "rwEnable", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "rwIsWrite", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "mrwIsWrite", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "rdReadValue", "type": "UInt", "chisel_type": "UInt", "width": "2.W"}, {"name": "rwReadValue", "type": "UInt", "chisel_type": "UInt", "width": "2.W"}, {"name": "mrwReadValue", "type": "Vec", "chisel_type": "Vec", "width": "2, UInt(2.W)"}]}}}, "output": {"code_after": "    class TestModule extends Module {\n      val io = IO(new Bundle {\n        val rdEnable = Input(Bool())\n        val writeData = Input(UInt(2.W))\n        val mrwWriteData = Input(Vec(2, UInt(2.W)))\n        val mrwWriteMask = Input(Vec(2, Bool()))\n\n        val rwEnable = Input(Bool())\n        val rwIsWrite = Input(Bool())\n        val mrwIsWrite = Input(Bool())\n\n        val rdReadValue = Output(UInt(2.W))\n        val rwReadValue = Output(UInt(2.W))\n        val mrwReadValue = Output(Vec(2, UInt(2.W)))\n      })\n\n      // Address value declared and driven before the SyncReadMem declaration.\n      // This is OK in Chisel, with the caveat that an intermediate wire is\n      // generated with the address after a memory port is instantiated -- if\n      // not then SFC and firtool are unable to infer the address value of the\n      // memory port correctly and results in an error\n      val addr = Wire(UInt(2.W))\n      addr := 0.U\n\n      val mem = SyncReadMem(4, UInt(2.W))\n      val vecMem = SyncReadMem(4, Vec(2, UInt(2.W)))\n\n      // Should elaborate correctly\n      io.rdReadValue := mem.read(addr, io.rdEnable)\n      // Should elaborate correctly\n      mem.write(addr, io.writeData)\n      // Should elaborate correctly\n      io.rwReadValue := mem.readWrite(addr, io.writeData, io.rwEnable, io.rwIsWrite)\n      // Should elaborate correctly\n      io.mrwReadValue := vecMem.readWrite(addr, io.mrwWriteData, io.mrwWriteMask, io.rwEnable, io.rwIsWrite)\n    }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "EnableShiftRegister", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "EnableShiftRegister", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "4.W"}, {"name": "shift", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "4.W"}]}}}, "output": {"code_after": "class EnableShiftRegister extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(4.W))\n    val shift = Input(Bool())\n    val out = Output(UInt(4.W))\n  })\n  val r0 = RegInit(0.U(4.W))\n  val r1 = RegInit(0.U(4.W))\n  val r2 = RegInit(0.U(4.W))\n  val r3 = RegInit(0.U(4.W))\n  when(io.shift) {\n    r0 := io.in\n    r1 := r0\n    r2 := r1\n    r3 := r2\n  }\n  io.out := r3\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "MulLookup", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "MulLookup", "io": {"inputs": [{"name": "x", "type": "UInt", "chisel_type": "UInt", "width": "w.W"}, {"name": "y", "type": "UInt", "chisel_type": "UInt", "width": "w.W"}], "outputs": [{"name": "z", "type": "UInt", "chisel_type": "UInt", "width": "(2 * w).W"}]}}}, "output": {"code_after": "class MulLookup(val w: Int) extends Module {\n  val io = IO(new Bundle {\n    val x = Input(UInt(w.W))\n    val y = Input(UInt(w.W))\n    val z = Output(UInt((2 * w).W))\n  })\n  val tbl = VecInit(\n    for {\n      i <- 0 until 1 << w\n      j <- 0 until 1 << w\n    } yield (i * j).asUInt((2 * w).W)\n  )\n  io.z := tbl(((io.x << w) | io.y))\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "SIntOps", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "SIntOps", "io": {"inputs": [{"name": "a", "type": "SInt", "chisel_type": "SInt", "width": "16.W"}, {"name": "b", "type": "SInt", "chisel_type": "SInt", "width": "16.W"}], "outputs": [{"name": "addout", "type": "SInt", "chisel_type": "SInt", "width": "16.W"}, {"name": "subout", "type": "SInt", "chisel_type": "SInt", "width": "16.W"}, {"name": "timesout", "type": "SInt", "chisel_type": "SInt", "width": "16.W"}, {"name": "divout", "type": "SInt", "chisel_type": "SInt", "width": "16.W"}, {"name": "modout", "type": "SInt", "chisel_type": "SInt", "width": "16.W"}, {"name": "lshiftout", "type": "SInt", "chisel_type": "SInt", "width": "16.W"}, {"name": "rshiftout", "type": "SInt", "chisel_type": "SInt", "width": "16.W"}, {"name": "lessout", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "greatout", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "eqout", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "noteqout", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "lesseqout", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "greateqout", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "negout", "type": "SInt", "chisel_type": "SInt", "width": "16.W"}]}}}, "output": {"code_after": "class SIntOps extends Module {\n  val io = IO(new Bundle {\n    val a = Input(SInt(16.W))\n    val b = Input(SInt(16.W))\n    val addout = Output(SInt(16.W))\n    val subout = Output(SInt(16.W))\n    val timesout = Output(SInt(16.W))\n    val divout = Output(SInt(16.W))\n    val modout = Output(SInt(16.W))\n    val lshiftout = Output(SInt(16.W))\n    val rshiftout = Output(SInt(16.W))\n    val lessout = Output(Bool())\n    val greatout = Output(Bool())\n    val eqout = Output(Bool())\n    val noteqout = Output(Bool())\n    val lesseqout = Output(Bool())\n    val greateqout = Output(Bool())\n    val negout = Output(SInt(16.W))\n  })\n\n  val a = io.a\n  val b = io.b\n\n  io.addout := a +% b\n  io.subout := a -% b\n  // TODO:\n  // io.timesout := (a * b)(15, 0)\n  // io.divout := a / Mux(b === 0.S, 1.S, b)\n  // io.divout := (a / b)(15, 0)\n  // io.modout := 0.S\n  // io.lshiftout := (a << 12)(15, 0) //  (a << ub(3, 0))(15, 0).toSInt\n  io.rshiftout := (a >> 8) // (a >> ub).toSInt\n  io.lessout := a < b\n  io.greatout := a > b\n  io.eqout := a === b\n  io.noteqout := (a =/= b)\n  io.lesseqout := a <= b\n  io.greateqout := a >= b\n  io.negout := -a(15, 0).asSInt\n  io.negout := (0.S -% a)\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "IOTesterModFill", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "IOTesterModFill", "io": {"inputs": [{"name": "in", "type": "VecInit", "chisel_type": "VecInit", "width": "Seq.fill(vecSize) { UInt() }"}], "outputs": [{"name": "out", "type": "VecInit", "chisel_type": "VecInit", "width": "Seq.fill(vecSize) { UInt() }"}]}}}, "output": {"code_after": "class IOTesterModFill(vecSize: Int) extends Module {\n  // This should generate a BindingException when we attempt to wire up the Vec.fill elements\n  //  since they're pure types and hence unsynthesizeable.\n  val io = IO(new Bundle {\n    val in = Input(VecInit(Seq.fill(vecSize) { UInt() }))\n    val out = Output(VecInit(Seq.fill(vecSize) { UInt() }))\n  })\n  io.out := io.in\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ChiselStack", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ChiselStack", "io": {"inputs": [{"name": "push", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "pop", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "en", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "dataIn", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}], "outputs": [{"name": "dataOut", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}]}}}, "output": {"code_after": "class ChiselStack(val depth: Int) extends Module {\n  val io = IO(new Bundle {\n    val push = Input(Bool())\n    val pop = Input(Bool())\n    val en = Input(Bool())\n    val dataIn = Input(UInt(32.W))\n    val dataOut = Output(UInt(32.W))\n  })\n\n  val stack_mem = Mem(depth, UInt(32.W))\n  val sp = RegInit(0.U(log2Ceil(depth + 1).W))\n  val out = RegInit(0.U(32.W))\n\n  when(io.en) {\n    when(io.push && (sp < depth.asUInt)) {\n      stack_mem(sp) := io.dataIn\n      sp := sp +% 1.U\n    }.elsewhen(io.pop && (sp > 0.U)) {\n      sp := sp -% 1.U\n    }\n    when(sp > 0.U) {\n      out := stack_mem(sp -% 1.U)\n    }\n  }\n  io.dataOut := out\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "InstanceNameModule", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "InstanceNameModule", "io": {"inputs": [{"name": "foo", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}], "outputs": [{"name": "bar", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}]}}}, "output": {"code_after": "class InstanceNameModule extends Module {\n  val io = IO(new Bundle {\n    val foo = Input(UInt(32.W))\n    val bar = Output(UInt(32.W))\n  })\n  val x = 3.U\n  val y = UInt(8.W)\n  val z = new Bundle {\n    val foo = UInt(8.W)\n  }\n\n  val q = Module(new Queue(UInt(32.W), 4))\n\n  io.bar := io.foo + x\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "UsesExtModuleAddViaInline", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "UsesExtModuleAddViaInline", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}]}}}, "output": {"code_after": "class UsesExtModuleAddViaInline extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n\n  val blackBoxAdd = Module(new ExtModuleAdd(5))\n  blackBoxAdd.io.in := io.in\n  io.out := blackBoxAdd.io.out\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "UsesExtModuleMinusViaResource", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "UsesExtModuleMinusViaResource", "io": {"inputs": [{"name": "in1", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}, {"name": "in2", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}]}}}, "output": {"code_after": "class UsesExtModuleMinusViaResource extends Module {\n  val io = IO(new Bundle {\n    val in1 = Input(UInt(16.W))\n    val in2 = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n\n  val mod0 = Module(new ExtModuleMinus)\n\n  mod0.io.in1 := io.in1\n  mod0.io.in2 := io.in2\n  io.out := mod0.io.out\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "UsesExtModuleMinusViaPath", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "UsesExtModuleMinusViaPath", "io": {"inputs": [{"name": "in1", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}, {"name": "in2", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}]}}}, "output": {"code_after": "class UsesExtModuleMinusViaPath extends Module {\n  val io = IO(new Bundle {\n    val in1 = Input(UInt(16.W))\n    val in2 = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n\n  val mod0 = Module(new ExtModuleMinusPath)\n\n  mod0.io.in1 := io.in1\n  mod0.io.in2 := io.in2\n  io.out := mod0.io.out\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "UsesBlackBoxAddViaInline", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "UsesBlackBoxAddViaInline", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}]}}}, "output": {"code_after": "class UsesBlackBoxAddViaInline extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n\n  val blackBoxAdd = Module(new BlackBoxAdd(5))\n  blackBoxAdd.io.in := io.in\n  io.out := blackBoxAdd.io.out\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "UsesBlackBoxMinusViaResource", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "UsesBlackBoxMinusViaResource", "io": {"inputs": [{"name": "in1", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}, {"name": "in2", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}]}}}, "output": {"code_after": "class UsesBlackBoxMinusViaResource extends Module {\n  val io = IO(new Bundle {\n    val in1 = Input(UInt(16.W))\n    val in2 = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n\n  val mod0 = Module(new BlackBoxMinus)\n\n  mod0.io.in1 := io.in1\n  mod0.io.in2 := io.in2\n  io.out := mod0.io.out\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "UsesBlackBoxMinusViaPath", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "UsesBlackBoxMinusViaPath", "io": {"inputs": [{"name": "in1", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}, {"name": "in2", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}]}}}, "output": {"code_after": "class UsesBlackBoxMinusViaPath extends Module {\n  val io = IO(new Bundle {\n    val in1 = Input(UInt(16.W))\n    val in2 = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n\n  val mod0 = Module(new BlackBoxMinusPath)\n\n  mod0.io.in1 := io.in1\n  mod0.io.in2 := io.in2\n  io.out := mod0.io.out\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "UIntOps", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "UIntOps", "io": {"inputs": [{"name": "a", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "b", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}], "outputs": [{"name": "addout", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "subout", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "addampout", "type": "UInt", "chisel_type": "UInt", "width": "33.W"}, {"name": "subampout", "type": "UInt", "chisel_type": "UInt", "width": "33.W"}, {"name": "timesout", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "divout", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "modout", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "lshiftout", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "rshiftout", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "lrotateout", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "rrotateout", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "lessout", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "greatout", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "eqout", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "noteqout", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "lesseqout", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "greateqout", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class UIntOps extends Module {\n  val io = IO(new Bundle {\n    val a = Input(UInt(32.W))\n    val b = Input(UInt(32.W))\n    val addout = Output(UInt(32.W))\n    val subout = Output(UInt(32.W))\n    val addampout = Output(UInt(33.W))\n    val subampout = Output(UInt(33.W))\n    val timesout = Output(UInt(32.W))\n    val divout = Output(UInt(32.W))\n    val modout = Output(UInt(32.W))\n    val lshiftout = Output(UInt(32.W))\n    val rshiftout = Output(UInt(32.W))\n    val lrotateout = Output(UInt(32.W))\n    val rrotateout = Output(UInt(32.W))\n    val lessout = Output(Bool())\n    val greatout = Output(Bool())\n    val eqout = Output(Bool())\n    val noteqout = Output(Bool())\n    val lesseqout = Output(Bool())\n    val greateqout = Output(Bool())\n  })\n\n  dontTouch(io)\n\n  val a = io.a\n  val b = io.b\n\n  io.addout := a +% b\n  io.subout := a -% b\n  io.addampout := a +& b\n  io.subampout := a -& b\n  io.timesout := (a * b)(31, 0)\n  io.divout := a / Mux(b === 0.U, 1.U, b)\n  io.modout := a % b\n  io.lshiftout := (a << b(3, 0))(31, 0)\n  io.rshiftout := a >> b\n  io.lrotateout := a.rotateLeft(5)\n  io.rrotateout := a.rotateRight(5)\n  io.lessout := a < b\n  io.greatout := a > b\n  io.eqout := a === b\n  io.noteqout := (a =/= b)\n  io.lesseqout := a <= b\n  io.greateqout := a >= b\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "GoodBoolConversion", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "GoodBoolConversion", "io": {"inputs": [{"name": "u", "type": "UInt", "chisel_type": "UInt", "width": "1.W"}], "outputs": [{"name": "b", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class GoodBoolConversion extends Module {\n  val io = IO(new Bundle {\n    val u = Input(UInt(1.W))\n    val b = Output(Bool())\n  })\n  io.b := io.u.asBool\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "BadBoolConversion", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "BadBoolConversion", "io": {"inputs": [{"name": "u", "type": "UInt", "chisel_type": "UInt", "width": "5.W"}], "outputs": [{"name": "b", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class BadBoolConversion extends Module {\n  val io = IO(new Bundle {\n    val u = Input(UInt(5.W))\n    val b = Output(Bool())\n  })\n  io.b := io.u.asBool\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ZeroWidthBoolConversion", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ZeroWidthBoolConversion", "io": {"inputs": [{"name": "u", "type": "UInt", "chisel_type": "UInt", "width": "0.W"}], "outputs": [{"name": "b", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class ZeroWidthBoolConversion extends Module {\n  val io = IO(new Bundle {\n    val u = Input(UInt(0.W))\n    val b = Output(Bool())\n  })\n  io.b := io.u.asBool\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "AdderTree", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "AdderTree", "io": {"inputs": [{"name": "numIn", "type": "Vec", "chisel_type": "Vec", "width": "vecSize, genType"}], "outputs": []}}}, "output": {"code_after": "class AdderTree[T <: Bits with Num[T]](genType: T, vecSize: Int) extends Module {\n  val io = IO(new Bundle {\n    val numIn = Input(Vec(vecSize, genType))\n    val numOut = Output(genType)\n  })\n  io.numOut := io.numIn.reduceTree((a: T, b: T) => (a + b))\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "MuchUsedModule", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "MuchUsedModule", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}]}}}, "output": {"code_after": "class MuchUsedModule extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n  io.out := io.in +% 1.U\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "UsesMuchUsedModule", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "UsesMuchUsedModule", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}]}}}, "output": {"code_after": "class UsesMuchUsedModule(addAnnos: Boolean) extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(16.W))\n    val out = Output(UInt(16.W))\n  })\n\n  val mod0 = Module(new MuchUsedModule)\n  val mod1 = Module(new MuchUsedModule)\n  val mod2 = Module(new MuchUsedModule)\n  val mod3 = Module(new MuchUsedModule)\n\n  mod0.io.in := io.in\n  mod1.io.in := mod0.io.out\n  mod2.io.in := mod1.io.out\n  mod3.io.in := mod2.io.out\n  io.out := mod3.io.out\n\n  if (addAnnos) {\n    doNotDedup(mod1)\n    doNotDedup(mod3)\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "Inner", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "Inner", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "w.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "w.W"}]}}}, "output": {"code_after": "      class Inner(val w: Int) extends Module {\n        val io = IO(new Bundle {\n          val in = Input(UInt(w.W))\n          val out = Output(UInt(w.W))\n        })\n      }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "Outer", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "Outer", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "w.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "w.W"}]}}}, "output": {"code_after": "      class Outer(val w: Int) extends Module {\n        val io = IO(new Bundle {\n          val in = Input(UInt(w.W))\n          val out = Output(UInt(w.W))\n        })\n        val i = Module(new Inner(w))\n        val iw = Wire(chiselTypeOf(i.io))\n        iw <> io\n        i.io <> iw\n      }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "Tbl", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "Tbl", "io": {"inputs": [{"name": "wi", "type": "UInt", "chisel_type": "UInt", "width": "log2Ceil(n).W"}, {"name": "ri", "type": "UInt", "chisel_type": "UInt", "width": "log2Ceil(n).W"}, {"name": "we", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "d", "type": "UInt", "chisel_type": "UInt", "width": "w.W"}], "outputs": [{"name": "o", "type": "UInt", "chisel_type": "UInt", "width": "w.W"}]}}}, "output": {"code_after": "class Tbl(w: Int, n: Int) extends Module {\n  val io = IO(new Bundle {\n    val wi = Input(UInt(log2Ceil(n).W))\n    val ri = Input(UInt(log2Ceil(n).W))\n    val we = Input(Bool())\n    val d = Input(UInt(w.W))\n    val o = Output(UInt(w.W))\n  })\n  val m = Mem(n, UInt(w.W))\n  io.o := m(io.ri)\n  when(io.we) {\n    m(io.wi) := io.d\n    when(io.ri === io.wi) {\n      io.o := io.d\n    }\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ParameterizedModule", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ParameterizedModule", "io": {"inputs": [{"name": "in", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "out", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class ParameterizedModule(invert: Boolean) extends Module {\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(Bool())\n  })\n  if (invert) {\n    io.out := !io.in\n  } else {\n    io.out := io.in\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "BundleWire", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "BundleWire", "io": {"inputs": [], "outputs": [{"name": "outs", "type": "Vec", "chisel_type": "Vec", "width": "n, new Coord"}]}}}, "output": {"code_after": "class BundleWire(n: Int) extends Module {\n  val io = IO(new Bundle {\n    val in = Input(new Coord)\n    val outs = Output(Vec(n, new Coord))\n  })\n  val coords = Wire(Vec(n, new Coord))\n  for (i <- 0 until n) {\n    coords(i) := io.in\n    io.outs(i) := coords(i)\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "MuchUsedModule", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "MuchUsedModule", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}]}}}, "output": {"code_after": "  class MuchUsedModule extends Module {\n    val io = IO(new Bundle {\n      val in = Input(UInt(16.W))\n      val out = Output(UInt(16.W))\n    })\n    io.out := io.in +% 1.U\n  }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "UsesMuchUsedModule", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "UsesMuchUsedModule", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}]}}}, "output": {"code_after": "  class UsesMuchUsedModule extends Module {\n    val io = IO(new Bundle {\n      val in = Input(UInt(16.W))\n      val out = Output(UInt(16.W))\n    })\n\n    val mod0 = Module(new MuchUsedModule)\n    val mod1 = Module(new MuchUsedModule)\n    val mod2 = Module(new MuchUsedModule)\n    val mod3 = Module(new MuchUsedModule)\n\n    mod0.io.in := io.in\n    mod1.io.in := mod0.io.out\n    mod2.io.in := mod1.io.out\n    mod3.io.in := mod2.io.out\n    io.out := mod3.io.out\n\n    // Give two annotations as single element of the seq - ensures previous API works by wrapping into a seq.\n    annotate(mod2)(Seq(new NoDedupAnnotation(mod2.toNamed)))\n    annotate(mod3)(Seq(new NoDedupAnnotation(mod3.toNamed)))\n\n    // Pass multiple annotations in the same seq - should get emitted out correctly.\n    val ports = Seq(mod1.io.in, mod1.io.out)\n    annotate(ports)({\n      ports.map(p => new DontTouchAnnotation(p.toTarget))\n    })\n  }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ModC", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ModC", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "widthC.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "widthC.W"}]}}}, "output": {"code_after": "class ModC(widthC: Int) extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(widthC.W))\n    val out = Output(UInt(widthC.W))\n  })\n  io.out := io.in\n\n  identify(this, s\"ModC($widthC)\")\n\n  identify(io.out, s\"ModC(ignore param)\")\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ModB", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ModB", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "widthB.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "widthB.W"}]}}}, "output": {"code_after": "class ModB(widthB: Int) extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(widthB.W))\n    val out = Output(UInt(widthB.W))\n  })\n  val modC = Module(new ModC(widthB))\n  modC.io.in := io.in\n  io.out := modC.io.out\n\n  identify(io.in, s\"modB.io.in annotated from inside modB\")\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "TopOfDiamond", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "TopOfDiamond", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}]}}}, "output": {"code_after": "class TopOfDiamond extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(UInt(32.W))\n  })\n  val x = Reg(UInt(32.W))\n  val y = Reg(UInt(32.W))\n\n  val modA = Module(new ModA(64))\n  val modB = Module(new ModB(32))\n\n  x := io.in\n  modA.io.in := x\n  modB.io.in := x\n\n  y := modA.io.out + modB.io.out\n  io.out := y\n\n  identify(this, s\"TopOfDiamond\\nWith\\nSome new lines\")\n\n  identify(modB.io.in, s\"modB.io.in annotated from outside modB\")\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "CastFromLit", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "CastFromLit", "io": {"inputs": [], "outputs": [{"name": "valid", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class CastFromLit(in: UInt) extends Module {\n  val io = IO(new Bundle {\n    val out = Output(EnumExample())\n    val valid = Output(Bool())\n  })\n\n  io.out := EnumExample(in)\n  io.valid := io.out.isValid\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "CastFromStringLit", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "CastFromStringLit", "io": {"inputs": [], "outputs": [{"name": "valid", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class CastFromStringLit(in: String) extends Module {\n  val io = IO(new Bundle {\n    val out = Output(EnumExample())\n    val valid = Output(Bool())\n  })\n\n  io.out := EnumExample(in)\n  io.valid := io.out.isValid\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "CastFromNonLit", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "CastFromNonLit", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "EnumExample.getWidth.W"}], "outputs": [{"name": "valid", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class CastFromNonLit extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(EnumExample.getWidth.W))\n    val out = Output(EnumExample())\n    val valid = Output(Bool())\n  })\n\n  io.out := EnumExample(io.in)\n  io.valid := io.out.isValid\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "SafeCastFromNonLit", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "SafeCastFromNonLit", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "EnumExample.getWidth.W"}], "outputs": [{"name": "valid", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class SafeCastFromNonLit extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(EnumExample.getWidth.W))\n    val out = Output(EnumExample())\n    val valid = Output(Bool())\n  })\n\n  val (enumVal, valid) = EnumExample.safe(io.in)\n  io.out := enumVal\n  io.valid := valid\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "CastFromNonLitWidth", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "CastFromNonLitWidth", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "width"}], "outputs": []}}}, "output": {"code_after": "class CastFromNonLitWidth(w: Option[Int] = None) extends Module {\n  val width = if (w.isDefined) w.get.W else UnknownWidth\n\n  val io = IO(new Bundle {\n    val in = Input(UInt(width))\n    val out = Output(EnumExample())\n  })\n\n  io.out := EnumExample(io.in)\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "EnumOps", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "EnumOps", "io": {"inputs": [], "outputs": [{"name": "lt", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "le", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "gt", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "ge", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "eq", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "ne", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class EnumOps(val xType: ChiselEnum, val yType: ChiselEnum) extends Module {\n  val io = IO(new Bundle {\n    val x = Input(xType())\n    val y = Input(yType())\n\n    val lt = Output(Bool())\n    val le = Output(Bool())\n    val gt = Output(Bool())\n    val ge = Output(Bool())\n    val eq = Output(Bool())\n    val ne = Output(Bool())\n  })\n\n  io.lt := io.x < io.y\n  io.le := io.x <= io.y\n  io.gt := io.x > io.y\n  io.ge := io.x >= io.y\n  io.eq := io.x === io.y\n  io.ne := io.x =/= io.y\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ChiselEnumFSM", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ChiselEnumFSM", "io": {"inputs": [{"name": "in", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "out", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class ChiselEnumFSM extends Module {\n  import ChiselEnumFSM.State\n  import ChiselEnumFSM.State._\n\n  // This FSM detects two 1's one after the other\n  val io = IO(new Bundle {\n    val in = Input(Bool())\n    val out = Output(Bool())\n    val state = Output(State())\n  })\n\n  val state = RegInit(sNone)\n\n  io.out := (state === sTwo1s)\n  io.state := state\n\n  switch(state) {\n    is(sNone) {\n      when(io.in) {\n        state := sOne1\n      }\n    }\n    is(sOne1) {\n      when(io.in) {\n        state := sTwo1s\n      }.otherwise {\n        state := sNone\n      }\n    }\n    is(sTwo1s) {\n      when(!io.in) {\n        state := sNone\n      }\n    }\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "LoadStoreExample", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "LoadStoreExample", "io": {"inputs": [], "outputs": [{"name": "load_or_store", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class LoadStoreExample extends Module {\n  val io = IO(new Bundle {\n    val opcode = Input(Opcode())\n    val load_or_store = Output(Bool())\n  })\n  io.load_or_store := io.opcode.isOneOf(Opcode.load, Opcode.store)\n  printf(p\"${io.opcode}\")\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "DPIIntrinsicTest", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests.simulator", "module": "DPIIntrinsicTest", "io": {"inputs": [{"name": "a", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "b", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}], "outputs": [{"name": "add_clocked_result", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "add_unclocked_result", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}]}}}, "output": {"code_after": "class DPIIntrinsicTest extends Module {\n  val io = IO(new Bundle {\n    val a = Input(UInt(32.W))\n    val b = Input(UInt(32.W))\n    val add_clocked_result = Output(UInt(32.W))\n    val add_unclocked_result = Output(UInt(32.W))\n  })\n\n  EmitDPIImplementation()\n\n  // Void function\n  RawClockedVoidFunctionCall(\"hello\")(clock, true.B)\n\n  // Stateless function with result\n  val result_clocked =\n    RawClockedNonVoidFunctionCall(\"add\", UInt(32.W), Some(Seq(\"lhs\", \"rhs\")), Some(\"result\"))(clock, true.B, io.a, io.b)\n  val result_unclocked =\n    RawUnclockedNonVoidFunctionCall(\"add\", UInt(32.W), Some(Seq(\"lhs\", \"rhs\")), Some(\"result\"))(true.B, io.a, io.b)\n\n  io.add_clocked_result := result_clocked\n  io.add_unclocked_result := result_unclocked\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "DPIAPITest", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests.simulator", "module": "DPIAPITest", "io": {"inputs": [{"name": "a", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "b", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}], "outputs": [{"name": "add_clocked_result", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "add_unclocked_result", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}]}}}, "output": {"code_after": "class DPIAPITest extends Module {\n  val io = IO(new Bundle {\n    val a = Input(UInt(32.W))\n    val b = Input(UInt(32.W))\n    val add_clocked_result = Output(UInt(32.W))\n    val add_unclocked_result = Output(UInt(32.W))\n  })\n\n  EmitDPIImplementation()\n\n  Hello()\n  val result_clocked = AddClocked(io.a, io.b)\n  val result_unclocked = AddUnclocked(io.a, io.b)\n\n  io.add_clocked_result := result_clocked\n  io.add_unclocked_result := result_unclocked\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "SharedConstantValDedup", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "SharedConstantValDedup", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}]}}}, "output": {"code_after": "class SharedConstantValDedup extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  io.out := io.in + DedupConsts.foo\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "SharedConstantValDedupTop", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "SharedConstantValDedupTop", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}]}}}, "output": {"code_after": "class SharedConstantValDedupTop extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  val inst0 = Module(new SharedConstantValDedup)\n  val inst1 = Module(new SharedConstantValDedup)\n  inst0.io.in := io.in\n  inst1.io.in := io.in\n  io.out := inst0.io.out + inst1.io.out\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "SharedConstantValDedupTopDesiredName", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "SharedConstantValDedupTopDesiredName", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}]}}}, "output": {"code_after": "class SharedConstantValDedupTopDesiredName extends Module {\n  val io = IO(new Bundle {\n    val in = Input(UInt(8.W))\n    val out = Output(UInt(8.W))\n  })\n  val inst0 = Module(new SharedConstantValDedup {\n    override def desiredName = \"foo\"\n  })\n  val inst1 = Module(new SharedConstantValDedup {\n    override def desiredName = \"bar\"\n  })\n  inst0.io.in := io.in\n  inst1.io.in := io.in\n  io.out := inst0.io.out + inst1.io.out\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "PipeInternalWires", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "PipeInternalWires", "io": {"inputs": [{"name": "a", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "b", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}], "outputs": []}}}, "output": {"code_after": "class PipeInternalWires extends Module {\n  import chisel3.util.Pipe\n  val io = IO(new Bundle {\n    val a = Input(Bool())\n    val b = Input(UInt(32.W))\n  })\n  val pipe = Module(new Pipe(UInt(32.W), 32))\n  pipe.io.enq.valid <> io.a\n  pipe.io.enq.bits <> io.b\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ComplexAssign", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "ComplexAssign", "io": {"inputs": [{"name": "e", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": []}}}, "output": {"code_after": "class ComplexAssign(w: Int) extends Module {\n  val io = IO(new Bundle {\n    val e = Input(Bool())\n    val in = Input(new Complex(UInt(w.W), UInt(w.W)))\n    val out = Output(new Complex(UInt(w.W), UInt(w.W)))\n  })\n  when(io.e) {\n    val tmp = Wire(new Complex(UInt(w.W), UInt(w.W)))\n    tmp := io.in\n    io.out.re := tmp.re\n    io.out.im := tmp.im\n  }.otherwise {\n    io.out.re := 0.U\n    io.out.im := 0.U\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "AttributeExample", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests.util", "module": "AttributeExample", "io": {"inputs": [{"name": "input", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}], "outputs": [{"name": "output", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}]}}}, "output": {"code_after": "  class AttributeExample extends Module {\n    val io = IO(new Bundle {\n      val input = Input(UInt(8.W))\n      val output = Output(UInt(8.W))\n    })\n\n    val reg = RegNext(io.input)\n\n    addAttribute(reg, \"synthesis translate_off\")\n\n    io.output := reg\n  }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "MyModule", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests.reflect", "module": "MyModule", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "4.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "4.W"}]}}}, "output": {"code_after": "    class MyModule extends Module {\n      val typ = UInt(4.W)\n      val vectyp = Vec(8, UInt(4.W))\n      val io = IO(new Bundle {\n        val in = Input(UInt(4.W))\n        val vec = Input(vectyp)\n        val out = Output(UInt(4.W))\n      })\n      val vec = Wire(vectyp)\n      val regvec = Reg(vectyp)\n      val wire = Wire(UInt(4.W))\n      val reg = RegNext(wire)\n\n      assertIO(io)\n      assertIO(io.in)\n      assertIO(io.out)\n      assertIO(io.vec(1))\n      assertIO(io.vec)\n      assertWire(vec)\n      assertWire(vec(0))\n      assertWire(wire)\n      assertReg(reg)\n      assertReg(regvec)\n      assertReg(regvec(2))\n      assertNone(typ)\n      assertNone(vectyp)\n    }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "GCD", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests.simulator", "module": "GCD", "io": {"inputs": [{"name": "a", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "b", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "loadValues", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "result", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}, {"name": "resultIsValid", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class GCD extends Module {\n  val io = IO(new Bundle {\n    val a = Input(UInt(32.W))\n    val b = Input(UInt(32.W))\n    val loadValues = Input(Bool())\n    val result = Output(UInt(32.W))\n    val resultIsValid = Output(Bool())\n  })\n  val x = Reg(UInt(32.W))\n  val y = Reg(UInt(32.W))\n  when(x > y) { x := x -% y }.otherwise { y := y -% x }\n  when(io.loadValues) { x := io.a; y := io.b }\n  io.result := x\n  io.resultIsValid := y === 0.U\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "Top", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests", "module": "Top", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}]}}}, "output": {"code_after": "      class Top extends Module {\n        val in = IO(Input(UInt(32.W)))\n        val out = IO(Output(UInt(32.W)))\n        val io = IO(new Bundle {\n          val in = Input(UInt(32.W))\n          val out = Output(UInt(32.W))\n        })\n        val definition = Definition(new AddOneBlackBox)\n        val i0 = Instance(definition)\n        val i1 = Instance(definition)\n        i0.io.in := in\n        out := i0.io.out\n        io <> i1.io\n      }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "HasPublicActualDirection", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests.experimental.hierarchy", "module": "HasPublicActualDirection", "io": {"inputs": [{"name": "input", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}], "outputs": [{"name": "output", "type": "UInt", "chisel_type": "UInt", "width": "8.W"}]}}}, "output": {"code_after": "  class HasPublicActualDirection extends Module {\n    val io = IO(new Bundle {\n      val input = Input(UInt(8.W))\n      val output = Output(UInt(8.W))\n    })\n\n    @public val inputDirection:  ActualDirection = DataMirror.directionOf(io.input)\n    @public val outputDirection: ActualDirection = DataMirror.directionOf(io.output)\n    @public val bundleDirection: ActualDirection = DataMirror.directionOf(io)\n  }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "Foo", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "chiselTests.stage.phases", "module": "Foo", "io": {"inputs": [{"name": "in", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "out", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "  class Foo extends Module {\n    override def desiredName: String = \"Foo\"\n    val io = IO(new Bundle {\n      val in = Input(Bool())\n      val out = Output(Bool())\n    })\n\n    io.out := ~io.in\n  }"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "UnitTestSuite", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.unittest", "module": "UnitTestSuite", "io": {"inputs": [], "outputs": [{"name": "finished", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class UnitTestSuite(implicit p: Parameters) extends Module {\n  val io = IO(new Bundle {\n    val finished = Output(Bool())\n  })\n\n  val tests = p(UnitTests)(p)\n\n  val s_idle :: s_start :: s_busy :: s_done :: Nil = Enum(4)\n  val state = RegInit(s_idle)\n  val tests_finished = VecInit(tests.map(_.io.finished)).reduce(_&&_)\n\n  tests.foreach { _.io.start := (state === s_start) }\n  io.finished := (state === s_done)\n\n  when (state === s_idle) { state := s_start }\n  when (state === s_start) { state := s_busy }\n  when (state === s_busy && tests_finished) { state := s_done }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "MultiLaneQueue", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.util", "module": "MultiLaneQueue", "io": {"inputs": [{"name": "enq_valid", "type": "UInt", "chisel_type": "UInt", "width": "laneBits1.W"}, {"name": "enq_bits", "type": "Vec", "chisel_type": "Vec", "width": "lanes, gen"}, {"name": "deq_ready", "type": "UInt", "chisel_type": "UInt", "width": "laneBits1.W"}], "outputs": [{"name": "enq_ready", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "deq_valid", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "deq_bits", "type": "Vec", "chisel_type": "Vec", "width": "lanes, gen"}]}}}, "output": {"code_after": "class MultiLaneQueue[T <: Data](gen: T, val lanes: Int, val rows: Int, val flow: Boolean = false, storage: LanePositionedQueue = FloppedLanePositionedQueue) extends Module {\n  val laneBits1 = log2Ceil(lanes+1) // [0, lanes]\n\n  val io = IO(new Bundle {\n    val enq_ready = Output(Bool())\n    val enq_valid = Input(UInt(laneBits1.W))\n    val enq_bits  = Input(Vec(lanes, gen))\n    // NOTE: deq_valid depends on deq_ready\n    val deq_ready = Input(UInt(laneBits1.W))\n    val deq_valid = Output(Bool())\n    val deq_bits  = Output(Vec(lanes, gen))\n  })\n\n  val queue = Module(storage(gen, lanes, rows, flow))\n\n  io.enq_ready := io.enq_valid <= queue.io.enq.ready\n  queue.io.enq.valid := Mux(io.enq_ready, io.enq_valid, 0.U)\n  queue.io.enq.bits := RotateVector.left(io.enq_bits, queue.io.enq_0_lane)\n\n  io.deq_valid := io.deq_ready <= queue.io.deq.valid\n  queue.io.deq.ready := Mux(io.deq_valid, io.deq_ready, 0.U)\n  io.deq_bits := RotateVector.right(queue.io.deq.bits, queue.io.deq_0_lane)\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "LCG16", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.util", "module": "LCG16", "io": {"inputs": [{"name": "inc", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "16.W"}]}}}, "output": {"code_after": "class LCG16 extends Module { \n  val io = IO(new Bundle {\n    val out = Output(UInt(16.W))\n    val inc = Input(Bool())\n  })\n  val state = Reg(UInt(32.W))\n  when (io.inc) {\n    state := state * 1103515245.U(32.W) + 12345.U(32.W)\n  }\n  io.out := state(30, 15)\n} "}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "LCG", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.util", "module": "LCG", "io": {"inputs": [{"name": "inc", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "w.W"}]}}}, "output": {"code_after": "class LCG(val w: Int) extends Module {\n  val io = IO(new Bundle {\n    val out = Output(UInt(w.W))\n    val inc = Input(Bool())\n  })\n  require(w > 0)\n  val numLCG16s : Int = (w+15)/16\n  val outs = Seq.fill(numLCG16s) { LCG16(io.inc) }\n  io.out := Cat(outs)\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "SimpleTimer", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.util", "module": "SimpleTimer", "io": {"inputs": [{"name": "start", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "stop", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "timeout", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class SimpleTimer(initCount: Int) extends Module {\n  val io = IO(new Bundle {\n    val start = Input(Bool())\n    val stop = Input(Bool())\n    val timeout = Output(Bool())\n  })\n\n  val countdown = Reg(UInt(log2Up(initCount).W))\n  val active = RegInit(false.B)\n\n  when (active) { countdown := countdown - 1.U }\n\n  when (io.start) {\n    active := true.B\n    countdown := (initCount - 1).U\n  }\n\n  when (io.stop) { active := false.B }\n\n  io.timeout := countdown === 0.U && active\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "DynamicTimer", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.util", "module": "DynamicTimer", "io": {"inputs": [{"name": "start", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "period", "type": "UInt", "chisel_type": "UInt", "width": "w.W"}, {"name": "stop", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "timeout", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class DynamicTimer(w: Int) extends Module {\n  val io = IO(new Bundle {\n    val start   = Input(Bool())\n    val period  = Input(UInt(w.W))\n    val stop    = Input(Bool())\n    val timeout = Output(Bool())\n  })\n\n  val countdown = RegInit(0.U(w.W))\n  val active = RegInit(false.B)\n\n  when (io.start) {\n    countdown := io.period\n    active := true.B\n  } .elsewhen (io.stop || countdown === 0.U) {\n    active := false.B\n  } .elsewhen (active) {\n    countdown := countdown - 1.U\n  }\n\n  io.timeout := countdown === 0.U && active\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ClockCrossingReg", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.util", "module": "ClockCrossingReg", "io": {"inputs": [{"name": "d", "type": "UInt", "chisel_type": "UInt", "width": "w.W"}, {"name": "en", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "q", "type": "UInt", "chisel_type": "UInt", "width": "w.W"}]}}}, "output": {"code_after": "class ClockCrossingReg(w: Int = 1, doInit: Boolean) extends Module {\n\n  override def desiredName = s\"ClockCrossingReg_w${w}\"\n\n  val io = IO(new Bundle{\n    val d = Input(UInt(w.W))\n    val q = Output(UInt(w.W))\n    val en = Input(Bool())\n  })\n\n  val cdc_reg = if (doInit) RegEnable(io.d, 0.U(w.W), io.en) else RegEnable(io.d, io.en)\n  io.q := cdc_reg\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "Repeater", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.util", "module": "Repeater", "io": {"inputs": [{"name": "repeat", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "full", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class Repeater[T <: Data](gen: T) extends Module\n{\n  override def desiredName = s\"Repeater_${gen.typeName}\"\n  val io = IO( new Bundle {\n    val repeat = Input(Bool())\n    val full = Output(Bool())\n    val enq = Flipped(Decoupled(gen.cloneType))\n    val deq = Decoupled(gen.cloneType)\n  } )\n\n  val full = RegInit(false.B)\n  val saved = Reg(gen.cloneType)\n\n  // When !full, a repeater is pass-through\n  io.deq.valid := io.enq.valid || full\n  io.enq.ready := io.deq.ready && !full\n  io.deq.bits := Mux(full, saved, io.enq.bits)\n  io.full := full\n\n  when (io.enq.fire &&  io.repeat) { full := true.B; saved := io.enq.bits }\n  when (io.deq.fire && !io.repeat) { full := false.B }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "MultiWidthFifo", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.util", "module": "MultiWidthFifo", "io": {"inputs": [], "outputs": [{"name": "count", "type": "UInt", "chisel_type": "UInt", "width": "log2Up(n + 1).W"}]}}}, "output": {"code_after": "class MultiWidthFifo(inW: Int, outW: Int, n: Int) extends Module {\n  val io = IO(new Bundle {\n    val in = Flipped(Decoupled(Bits(inW.W)))\n    val out = Decoupled(Bits(outW.W))\n    val count = Output(UInt(log2Up(n + 1).W))\n  })\n\n  if (inW == outW) {\n    val q = Module(new Queue(Bits(inW.W), n))\n    q.io.enq <> io.in\n    io.out <> q.io.deq\n    io.count := q.io.count\n  } else if (inW > outW) {\n    val nBeats = inW / outW\n\n    require(inW % outW == 0, s\"MultiWidthFifo: in: $inW not divisible by out: $outW\")\n    require(n % nBeats == 0, s\"Cannot store $n output words when output beats is $nBeats\")\n\n    val wdata = Reg(Vec(n / nBeats, Bits(inW.W)))\n    val rdata = VecInit(wdata.flatMap { indat =>\n      (0 until nBeats).map(i => indat(outW * (i + 1) - 1, outW * i)) })\n\n    val head = RegInit(0.U(log2Up(n / nBeats).W))\n    val tail = RegInit(0.U(log2Up(n).W))\n    val size = RegInit(0.U(log2Up(n + 1).W))\n\n    when (io.in.fire) {\n      wdata(head) := io.in.bits\n      head := head + 1.U\n    }\n\n    when (io.out.fire) { tail := tail + 1.U }\n\n    size := MuxCase(size, Seq(\n      (io.in.fire && io.out.fire) -> (size + (nBeats - 1).U),\n      io.in.fire -> (size + nBeats.U),\n      io.out.fire -> (size - 1.U)))\n\n    io.out.valid := size > 0.U\n    io.out.bits := rdata(tail)\n    io.in.ready := size < n.U\n    io.count := size\n  } else {\n    val nBeats = outW / inW\n\n    require(outW % inW == 0, s\"MultiWidthFifo: out: $outW not divisible by in: $inW\")\n\n    val wdata = Reg(Vec(n * nBeats, Bits(inW.W)))\n    val rdata = VecInit(Seq.tabulate(n) { i =>\n      Cat(wdata.slice(i * nBeats, (i + 1) * nBeats).reverse)})\n\n    val head = RegInit(0.U(log2Up(n * nBeats).W))\n    val tail = RegInit(0.U(log2Up(n).W))\n    val size = RegInit(0.U(log2Up(n * nBeats + 1).W))\n\n    when (io.in.fire) {\n      wdata(head) := io.in.bits\n      head := head + 1.U\n    }\n\n    when (io.out.fire) { tail := tail + 1.U }\n\n    size := MuxCase(size, Seq(\n      (io.in.fire && io.out.fire) -> (size - (nBeats - 1).U),\n      io.in.fire -> (size + 1.U),\n      io.out.fire -> (size - nBeats.U)))\n\n    io.count := size >> log2Up(nBeats).U\n    io.out.valid := io.count > 0.U\n    io.out.bits := rdata(tail)\n    io.in.ready := size < (n * nBeats).U\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "PlusArgTimeout", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.util", "module": "PlusArgTimeout", "io": {"inputs": [{"name": "count", "type": "UInt", "chisel_type": "UInt", "width": "width.W"}], "outputs": []}}}, "output": {"code_after": "class PlusArgTimeout(val format: String, val default: BigInt, val docstring: String, val width: Int) extends Module {\n  val io = IO(new Bundle {\n    val count = Input(UInt(width.W))\n  })\n  val max = Module(new plusarg_reader(format, default, docstring, width)).io.out\n  when (max > 0.U) {\n    assert (io.count < max, s\"Timeout exceeded: $docstring\")\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "ResetCatchAndSync", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.util", "module": "ResetCatchAndSync", "io": {"inputs": [], "outputs": [{"name": "sync_reset", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class ResetCatchAndSync (sync: Int = 3) extends Module {\n\n  override def desiredName = s\"ResetCatchAndSync_d${sync}\"\n\n  val io = IO(new Bundle {\n    val sync_reset = Output(Bool())\n    val psd = Input(new PSDTestMode())\n  })\n\n  // Bypass both the resets to the flops themselves (to prevent DFT holes on\n  // those flops) and on the output of the synchronizer circuit (to control\n  // reset to any flops this circuit drives).\n\n  val post_psd_reset = Mux(io.psd.test_mode, io.psd.test_mode_reset, reset.asBool)\n  withReset(post_psd_reset) {\n    io.sync_reset := Mux(io.psd.test_mode, io.psd.test_mode_reset,\n      ~AsyncResetSynchronizerShiftReg(true.B, sync))\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "DelayQueue", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.util", "module": "DelayQueue", "io": {"inputs": [{"name": "timer", "type": "UInt", "chisel_type": "UInt", "width": "width.W"}, {"name": "delay", "type": "UInt", "chisel_type": "UInt", "width": "width.W"}], "outputs": []}}}, "output": {"code_after": "class DelayQueue[T <: Data](gen: T, entries: Int, width: Int) extends Module {\n  val io = IO(new Bundle {\n    val enq = Flipped(DecoupledIO(gen))\n    val deq = DecoupledIO(gen)\n    val timer = Input(UInt(width.W))\n    val delay = Input(UInt(width.W))\n  })\n\n  val q = Module(new Queue(new Bundle {\n    val data = gen.cloneType\n    val time = UInt(width.W)\n  }, entries, flow=true))\n\n  val delay_r = RegInit(0.U(width.W))\n  when (delay_r =/= io.delay) {\n    delay_r := io.delay\n    //assert(q.io.count == 0, \"Undefined behavior when delay is changed while queue has elements.\")\n  }\n\n  q.io.enq.bits.data := io.enq.bits\n  q.io.enq.bits.time := io.timer\n  q.io.enq.valid := io.enq.fire\n  io.enq.ready := q.io.enq.ready\n\n  io.deq.bits := q.io.deq.bits.data\n  io.deq.valid := q.io.deq.valid && ((io.timer - q.io.deq.bits.time) >= delay_r)\n  q.io.deq.ready := io.deq.fire\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "TraceSinkArbiter", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.trace", "module": "TraceSinkArbiter", "io": {"inputs": [{"name": "target", "type": "UInt", "chisel_type": "UInt", "width": "TraceSinkTarget.width.W"}], "outputs": []}}}, "output": {"code_after": "class TraceSinkArbiter(nSeq : Seq[Int], use_monitor: Boolean = false, monitor_name: String = \"unknown\") extends Module {\n  val io = IO(new Bundle {\n    val target = Input(UInt(TraceSinkTarget.width.W))\n    val in = Flipped(Decoupled(UInt(8.W)))\n    val out = Vec(nSeq.size, Decoupled(UInt(8.W)))\n  })\n  val nVec = VecInit(nSeq.map(_.U))\n  io.in.ready := Mux(nVec.contains(io.target), io.out(nVec.indexWhere(_ === io.target)).ready, true.B)\n  io.out.zipWithIndex.foreach { case (o, i) => \n    o.valid := io.in.valid && (io.target === nVec(i))\n    o.bits := io.in.bits\n  }\n\n  if (use_monitor) {\n    val monitor = Module(new TraceSinkMonitor(s\"trace_monitor_$monitor_name.encoded.trace\"))\n    monitor.io.in_fire := io.in.valid && io.in.ready\n    monitor.io.in_byte := io.in.bits\n    monitor.io.clk := clock\n    monitor.io.reset := reset\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "TraceCoreIngress", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.trace", "module": "TraceCoreIngress", "io": {"inputs": [{"name": "valid", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "taken", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "is_branch", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "is_jal", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "is_jalr", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "is_compressed", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "insn", "type": "UInt", "chisel_type": "UInt", "width": "params.xlen.W"}, {"name": "pc", "type": "UInt", "chisel_type": "UInt", "width": "params.xlen.W"}, {"name": "interrupt", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "exception", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "trap_return", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": []}}}, "output": {"code_after": "class TraceCoreIngress(val params: TraceCoreParams) extends Module {\n  val io = IO(new Bundle {\n    val in = new Bundle {\n      val valid = Input(Bool())\n      val taken = Input(Bool())\n      val is_branch = Input(Bool())\n      val is_jal = Input(Bool())\n      val is_jalr = Input(Bool())\n      val is_compressed = Input(Bool())\n      val insn = Input(UInt(params.xlen.W))\n      val pc = Input(UInt(params.xlen.W))\n      val interrupt = Input(Bool())\n      val exception = Input(Bool())\n      val trap_return = Input(Bool())\n    }\n    val out = Output(new TraceCoreGroup(params))\n  })\n\n  def gen_itype(insn: UInt, taken: Bool, is_branch: Bool, is_jal: Bool, is_jalr: Bool) = {\n    val itype = Wire(TraceItype())\n    when (io.in.exception) {\n        itype := TraceItype.ITException\n    }.elsewhen (io.in.interrupt) {\n        itype := TraceItype.ITInterrupt\n    }.elsewhen (io.in.trap_return) {\n        itype := TraceItype.ITReturn\n    }.elsewhen (is_branch && taken) {\n        itype := TraceItype.ITBrTaken\n    }.elsewhen (is_branch && !taken) {\n        itype := TraceItype.ITBrNTaken\n    }.elsewhen (is_jal) {\n        itype := TraceItype.ITInJump\n    }.elsewhen (is_jalr) {\n        itype := TraceItype.ITUnJump\n    }.otherwise {\n        itype := TraceItype.ITNothing\n    }\n    itype\n}\n  \n  io.out.iretire := io.in.valid\n  io.out.iaddr := io.in.pc\n  io.out.itype := gen_itype(io.in.insn, io.in.taken, io.in.is_branch, io.in.is_jal, io.in.is_jalr)\n  io.out.ilastsize := io.in.valid && !io.in.is_compressed // 2^1 if non-compressed, 2^0 if compressed\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "MulAddRecFNPipe", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.tile", "module": "MulAddRecFNPipe", "io": {"inputs": [{"name": "validin", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "op", "type": "Bits", "chisel_type": "Bits", "width": "2.W"}, {"name": "a", "type": "Bits", "chisel_type": "Bits", "width": "(expWidth + sigWidth + 1).W"}, {"name": "b", "type": "Bits", "chisel_type": "Bits", "width": "(expWidth + sigWidth + 1).W"}, {"name": "c", "type": "Bits", "chisel_type": "Bits", "width": "(expWidth + sigWidth + 1).W"}, {"name": "roundingMode", "type": "UInt", "chisel_type": "UInt", "width": "3.W"}, {"name": "detectTininess", "type": "UInt", "chisel_type": "UInt", "width": "1.W"}], "outputs": [{"name": "out", "type": "Bits", "chisel_type": "Bits", "width": "(expWidth + sigWidth + 1).W"}, {"name": "exceptionFlags", "type": "Bits", "chisel_type": "Bits", "width": "5.W"}, {"name": "validout", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class MulAddRecFNPipe(latency: Int, expWidth: Int, sigWidth: Int) extends Module\n{\n    override def desiredName = s\"MulAddRecFNPipe_l${latency}_e${expWidth}_s${sigWidth}\"\n    require(latency<=2)\n\n    val io = IO(new Bundle {\n        val validin = Input(Bool())\n        val op = Input(Bits(2.W))\n        val a = Input(Bits((expWidth + sigWidth + 1).W))\n        val b = Input(Bits((expWidth + sigWidth + 1).W))\n        val c = Input(Bits((expWidth + sigWidth + 1).W))\n        val roundingMode   = Input(UInt(3.W))\n        val detectTininess = Input(UInt(1.W))\n        val out = Output(Bits((expWidth + sigWidth + 1).W))\n        val exceptionFlags = Output(Bits(5.W))\n        val validout = Output(Bool())\n    })\n\n    //------------------------------------------------------------------------\n    //------------------------------------------------------------------------\n\n    val mulAddRecFNToRaw_preMul = Module(new hardfloat.MulAddRecFNToRaw_preMul(expWidth, sigWidth))\n    val mulAddRecFNToRaw_postMul = Module(new hardfloat.MulAddRecFNToRaw_postMul(expWidth, sigWidth))\n\n    mulAddRecFNToRaw_preMul.io.op := io.op\n    mulAddRecFNToRaw_preMul.io.a  := io.a\n    mulAddRecFNToRaw_preMul.io.b  := io.b\n    mulAddRecFNToRaw_preMul.io.c  := io.c\n\n    val mulAddResult =\n        (mulAddRecFNToRaw_preMul.io.mulAddA *\n             mulAddRecFNToRaw_preMul.io.mulAddB) +&\n            mulAddRecFNToRaw_preMul.io.mulAddC\n\n    val valid_stage0 = Wire(Bool())\n    val roundingMode_stage0 = Wire(UInt(3.W))\n    val detectTininess_stage0 = Wire(UInt(1.W))\n\n    val postmul_regs = if(latency>0) 1 else 0\n    mulAddRecFNToRaw_postMul.io.fromPreMul   := Pipe(io.validin, mulAddRecFNToRaw_preMul.io.toPostMul, postmul_regs).bits\n    mulAddRecFNToRaw_postMul.io.mulAddResult := Pipe(io.validin, mulAddResult, postmul_regs).bits\n    mulAddRecFNToRaw_postMul.io.roundingMode := Pipe(io.validin, io.roundingMode, postmul_regs).bits\n    roundingMode_stage0                      := Pipe(io.validin, io.roundingMode, postmul_regs).bits\n    detectTininess_stage0                    := Pipe(io.validin, io.detectTininess, postmul_regs).bits\n    valid_stage0                             := Pipe(io.validin, false.B, postmul_regs).valid\n\n    //------------------------------------------------------------------------\n    //------------------------------------------------------------------------\n\n    val roundRawFNToRecFN = Module(new hardfloat.RoundRawFNToRecFN(expWidth, sigWidth, 0))\n\n    val round_regs = if(latency==2) 1 else 0\n    roundRawFNToRecFN.io.invalidExc         := Pipe(valid_stage0, mulAddRecFNToRaw_postMul.io.invalidExc, round_regs).bits\n    roundRawFNToRecFN.io.in                 := Pipe(valid_stage0, mulAddRecFNToRaw_postMul.io.rawOut, round_regs).bits\n    roundRawFNToRecFN.io.roundingMode       := Pipe(valid_stage0, roundingMode_stage0, round_regs).bits\n    roundRawFNToRecFN.io.detectTininess     := Pipe(valid_stage0, detectTininess_stage0, round_regs).bits\n    io.validout                             := Pipe(valid_stage0, false.B, round_regs).valid\n\n    roundRawFNToRecFN.io.infiniteExc := false.B\n\n    io.out            := roundRawFNToRecFN.io.out\n    io.exceptionFlags := roundRawFNToRecFN.io.exceptionFlags\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "RRTestCombinational", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.regmapper", "module": "RRTestCombinational", "io": {"inputs": [{"name": "rready", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "wvalid", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "wdata", "type": "UInt", "chisel_type": "UInt", "width": "bits.W"}], "outputs": [{"name": "rvalid", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "rdata", "type": "UInt", "chisel_type": "UInt", "width": "bits.W"}, {"name": "wready", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class RRTestCombinational(val bits: Int, rvalid: Bool => Bool, wready: Bool => Bool) extends Module\n{\n  val io = IO(new Bundle {\n    val rvalid = Output(Bool())\n    val rready = Input(Bool())\n    val rdata  = Output(UInt(bits.W))\n    val wvalid = Input(Bool())\n    val wready = Output(Bool())\n    val wdata  = Input(UInt(bits.W))\n  })\n\n  val reg = RegInit(0.U(bits.W))\n\n  val rvalid_s = rvalid(io.rready)\n  val wready_s = wready(io.wvalid)\n  io.rvalid := rvalid_s\n  io.wready := wready_s\n\n  io.rdata := Mux(rvalid_s && io.rready, reg, 0.U)\n  when (io.wvalid && wready_s) { reg := io.wdata }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "BusyRegisterCrossing", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.regmapper", "module": "BusyRegisterCrossing", "io": {"inputs": [{"name": "bypass", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "master_request_valid", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "master_response_ready", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "crossing_request_ready", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "master_request_ready", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "master_response_valid", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "crossing_request_valid", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class BusyRegisterCrossing extends Module {\n  val io = IO(new Bundle {\n    val bypass                  = Input(Bool())\n    val master_request_valid    = Input(Bool())\n    val master_request_ready    = Output(Bool())\n    val master_response_valid   = Output(Bool())\n    val master_response_ready   = Input(Bool())\n    val crossing_request_valid  = Output(Bool())\n    val crossing_request_ready  = Input(Bool())\n    // ... no crossing_response_ready; we are always ready\n  })\n\n  val busy   = RegInit(false.B)\n  val bypass = Reg(Bool())\n\n  when (io.crossing_request_ready || Mux(busy, bypass, io.bypass)) {\n    busy := Mux(busy, !io.master_response_ready, io.master_request_valid)\n  }\n\n  when (io.master_request_valid && io.master_request_ready) {\n    bypass := io.bypass\n  }\n\n  io.crossing_request_valid := io.master_request_valid && !io.bypass && !busy\n  io.master_request_ready   := (io.bypass || io.crossing_request_ready) && !busy\n  io.master_response_valid  := (bypass    || io.crossing_request_ready) &&  busy\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "RegisterCrossingAssertion", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.regmapper", "module": "RegisterCrossingAssertion", "io": {"inputs": [{"name": "master_bypass", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "slave_reset", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": []}}}, "output": {"code_after": "class RegisterCrossingAssertion extends Module {\n  val io = IO(new Bundle {\n    val master_bypass = Input(Bool())\n    val slave_reset = Input(Bool())\n  })\n\n  val up = RegInit(false.B)\n  up := !io.slave_reset\n\n  assert (io.master_bypass || !up || !io.slave_reset)\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "AMOALU", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.rocket", "module": "AMOALU", "io": {"inputs": [{"name": "mask", "type": "UInt", "chisel_type": "UInt", "width": "(operandBits / 8).W"}, {"name": "cmd", "type": "UInt", "chisel_type": "UInt", "width": "M_SZ.W"}, {"name": "lhs", "type": "UInt", "chisel_type": "UInt", "width": "operandBits.W"}, {"name": "rhs", "type": "UInt", "chisel_type": "UInt", "width": "operandBits.W"}], "outputs": [{"name": "out", "type": "UInt", "chisel_type": "UInt", "width": "operandBits.W"}, {"name": "out_unmasked", "type": "UInt", "chisel_type": "UInt", "width": "operandBits.W"}]}}}, "output": {"code_after": "class AMOALU(operandBits: Int)(implicit p: Parameters) extends Module {\n  val minXLen = 32\n  val widths = (0 to log2Ceil(operandBits / minXLen)).map(minXLen << _)\n\n  val io = IO(new Bundle {\n    val mask = Input(UInt((operandBits / 8).W))\n    val cmd = Input(UInt(M_SZ.W))\n    val lhs = Input(UInt(operandBits.W))\n    val rhs = Input(UInt(operandBits.W))\n    val out = Output(UInt(operandBits.W))\n    val out_unmasked = Output(UInt(operandBits.W))\n  })\n\n  val max = io.cmd === M_XA_MAX || io.cmd === M_XA_MAXU\n  val min = io.cmd === M_XA_MIN || io.cmd === M_XA_MINU\n  val add = io.cmd === M_XA_ADD\n  val logic_and = io.cmd === M_XA_OR || io.cmd === M_XA_AND\n  val logic_xor = io.cmd === M_XA_XOR || io.cmd === M_XA_OR\n\n  val adder_out = {\n    // partition the carry chain to support sub-xLen addition\n    val mask = ~(0.U(operandBits.W) +: widths.init.map(w => !io.mask(w/8-1) << (w-1))).reduce(_|_)\n    (io.lhs & mask) + (io.rhs & mask)\n  }\n\n  val less = {\n    // break up the comparator so the lower parts will be CSE'd\n    def isLessUnsigned(x: UInt, y: UInt, n: Int): Bool = {\n      if (n == minXLen) x(n-1, 0) < y(n-1, 0)\n      else x(n-1, n/2) < y(n-1, n/2) || x(n-1, n/2) === y(n-1, n/2) && isLessUnsigned(x, y, n/2)\n    }\n\n    def isLess(x: UInt, y: UInt, n: Int): Bool = {\n      val signed = {\n        val mask = M_XA_MIN ^ M_XA_MINU\n        (io.cmd & mask) === (M_XA_MIN & mask)\n      }\n      Mux(x(n-1) === y(n-1), isLessUnsigned(x, y, n), Mux(signed, x(n-1), y(n-1)))\n    }\n\n    PriorityMux(widths.reverse.map(w => (io.mask(w/8/2), isLess(io.lhs, io.rhs, w))))\n  }\n\n  val minmax = Mux(Mux(less, min, max), io.lhs, io.rhs)\n  val logic =\n    Mux(logic_and, io.lhs & io.rhs, 0.U) |\n    Mux(logic_xor, io.lhs ^ io.rhs, 0.U)\n  val out =\n    Mux(add,                    adder_out,\n    Mux(logic_and || logic_xor, logic,\n                                minmax))\n\n  val wmask = FillInterleaved(8, io.mask)\n  io.out := wmask & out | ~wmask & io.lhs\n  io.out_unmasked := out\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "BreakpointUnit", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.rocket", "module": "BreakpointUnit", "io": {"inputs": [{"name": "bp", "type": "Vec", "chisel_type": "Vec", "width": "n, new BP"}, {"name": "pc", "type": "UInt", "chisel_type": "UInt", "width": "vaddrBits.W"}, {"name": "ea", "type": "UInt", "chisel_type": "UInt", "width": "vaddrBits.W"}, {"name": "mcontext", "type": "UInt", "chisel_type": "UInt", "width": "coreParams.mcontextWidth.W"}, {"name": "scontext", "type": "UInt", "chisel_type": "UInt", "width": "coreParams.scontextWidth.W"}], "outputs": [{"name": "xcpt_if", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "xcpt_ld", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "xcpt_st", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "debug_if", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "debug_ld", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "debug_st", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "bpwatch", "type": "Vec", "chisel_type": "Vec", "width": "n, new BPWatch(1)"}]}}}, "output": {"code_after": "class BreakpointUnit(n: Int)(implicit val p: Parameters) extends Module with HasCoreParameters {\n  val io = IO(new Bundle {\n    val status = Input(new MStatus())\n    val bp = Input(Vec(n, new BP))\n    val pc = Input(UInt(vaddrBits.W))\n    val ea = Input(UInt(vaddrBits.W))\n    val mcontext = Input(UInt(coreParams.mcontextWidth.W))\n    val scontext = Input(UInt(coreParams.scontextWidth.W))\n    val xcpt_if  = Output(Bool())\n    val xcpt_ld  = Output(Bool())\n    val xcpt_st  = Output(Bool())\n    val debug_if = Output(Bool())\n    val debug_ld = Output(Bool())\n    val debug_st = Output(Bool())\n    val bpwatch  = Output(Vec(n, new BPWatch(1)))\n  })\n\n  io.xcpt_if := false.B\n  io.xcpt_ld := false.B\n  io.xcpt_st := false.B\n  io.debug_if := false.B\n  io.debug_ld := false.B\n  io.debug_st := false.B\n\n  (io.bpwatch zip io.bp).foldLeft((true.B, true.B, true.B)) { case ((ri, wi, xi), (bpw, bp)) =>\n    val en = bp.control.enabled(io.status)\n    val cx = bp.contextMatch(io.mcontext, io.scontext)\n    val r = en && bp.control.r && bp.addressMatch(io.ea) && cx\n    val w = en && bp.control.w && bp.addressMatch(io.ea) && cx\n    val x = en && bp.control.x && bp.addressMatch(io.pc) && cx\n    val end = !bp.control.chain\n    val action = bp.control.action\n\n    bpw.action := action\n    bpw.valid(0) := false.B\n    bpw.rvalid(0) := false.B\n    bpw.wvalid(0) := false.B\n    bpw.ivalid(0) := false.B\n\n    when (end && r && ri) { io.xcpt_ld := (action === 0.U); io.debug_ld := (action === 1.U); bpw.valid(0) := true.B; bpw.rvalid(0) := true.B }\n    when (end && w && wi) { io.xcpt_st := (action === 0.U); io.debug_st := (action === 1.U); bpw.valid(0) := true.B; bpw.wvalid(0) := true.B }\n    when (end && x && xi) { io.xcpt_if := (action === 0.U); io.debug_if := (action === 1.U); bpw.valid(0) := true.B; bpw.ivalid(0) := true.B }\n\n    (end || r, end || w, end || x)\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "RVCExpander", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.rocket", "module": "RVCExpander", "io": {"inputs": [{"name": "in", "type": "UInt", "chisel_type": "UInt", "width": "32.W"}], "outputs": [{"name": "rvc", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "ill", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class RVCExpander(useAddiForMv: Boolean = false)(implicit val p: Parameters) extends Module with HasCoreParameters {\n  val io = IO(new Bundle {\n    val in = Input(UInt(32.W))\n    val out = Output(new ExpandedInstruction)\n    val rvc = Output(Bool())\n    val ill = Output(Bool())\n  })\n\n  if (usingCompressed) {\n    io.rvc := io.in(1,0) =/= 3.U\n    val decoder = new RVCDecoder(io.in, xLen, fLen, useAddiForMv)\n    io.out := decoder.decode\n    io.ill := decoder.ill\n  } else {\n    io.rvc := false.B\n    io.out := new RVCDecoder(io.in, xLen, fLen, useAddiForMv).passthrough\n    io.ill := false.B // only used for RVC\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "PMPChecker", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.rocket", "module": "PMPChecker", "io": {"inputs": [{"name": "prv", "type": "UInt", "chisel_type": "UInt", "width": "PRV.SZ.W"}, {"name": "pmp", "type": "Vec", "chisel_type": "Vec", "width": "nPMPs, new PMP"}, {"name": "addr", "type": "UInt", "chisel_type": "UInt", "width": "paddrBits.W"}, {"name": "size", "type": "UInt", "chisel_type": "UInt", "width": "log2Ceil(lgMaxSize + 1).W"}], "outputs": [{"name": "r", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "w", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "x", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class PMPChecker(lgMaxSize: Int)(implicit val p: Parameters) extends Module\n    with HasCoreParameters {\n  override def desiredName = s\"PMPChecker_s${lgMaxSize}\"\n  val io = IO(new Bundle {\n    val prv = Input(UInt(PRV.SZ.W))\n    val pmp = Input(Vec(nPMPs, new PMP))\n    val addr = Input(UInt(paddrBits.W))\n    val size = Input(UInt(log2Ceil(lgMaxSize + 1).W))\n    val r = Output(Bool())\n    val w = Output(Bool())\n    val x = Output(Bool())\n  })\n\n  val default = if (io.pmp.isEmpty) true.B else io.prv > PRV.S.U\n  val pmp0 = WireInit(0.U.asTypeOf(new PMP))\n  pmp0.cfg.r := default\n  pmp0.cfg.w := default\n  pmp0.cfg.x := default\n\n  val res = (io.pmp zip (pmp0 +: io.pmp)).reverse.foldLeft(pmp0) { case (prev, (pmp, prevPMP)) =>\n    val hit = pmp.hit(io.addr, io.size, lgMaxSize, prevPMP)\n    val ignore = default && !pmp.cfg.l\n    val aligned = pmp.aligned(io.addr, io.size, lgMaxSize, prevPMP)\n\n    for ((name, idx) <- Seq(\"no\", \"TOR\", if (pmpGranularity <= 4) \"NA4\" else \"\", \"NAPOT\").zipWithIndex; if name.nonEmpty)\n      property.cover(pmp.cfg.a === idx.U, s\"The cfg access is set to ${name} access \", \"Cover PMP access mode setting\")\n\n    property.cover(pmp.cfg.l === 0x1.U, s\"The cfg lock is set to high \", \"Cover PMP lock mode setting\")\n   \n    // Not including Write and no Read permission as the combination is reserved\n    for ((name, idx) <- Seq(\"no\", \"RO\", \"\", \"RW\", \"X\", \"RX\", \"\", \"RWX\").zipWithIndex; if name.nonEmpty)\n      property.cover((Cat(pmp.cfg.x, pmp.cfg.w, pmp.cfg.r) === idx.U), s\"The permission is set to ${name} access \", \"Cover PMP access permission setting\")\n\n    for ((name, idx) <- Seq(\"\", \"TOR\", if (pmpGranularity <= 4) \"NA4\" else \"\", \"NAPOT\").zipWithIndex; if name.nonEmpty) {\n      property.cover(!ignore && hit && aligned && pmp.cfg.a === idx.U, s\"The access matches ${name} mode \", \"Cover PMP access\")\n      property.cover(pmp.cfg.l && hit && aligned && pmp.cfg.a === idx.U, s\"The access matches ${name} mode with lock bit high\", \"Cover PMP access with lock bit\")\n    }\n\n    val cur = WireInit(pmp)\n    cur.cfg.r := aligned && (pmp.cfg.r || ignore)\n    cur.cfg.w := aligned && (pmp.cfg.w || ignore)\n    cur.cfg.x := aligned && (pmp.cfg.x || ignore)\n    Mux(hit, cur, prev)\n  }\n\n  io.r := res.cfg.r\n  io.w := res.cfg.w\n  io.x := res.cfg.x\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "TestHarness", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.system", "module": "TestHarness", "io": {"inputs": [], "outputs": [{"name": "success", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class TestHarness()(implicit p: Parameters) extends Module {\n  val io = IO(new Bundle {\n    val success = Output(Bool())\n  })\n\n  val ldut = LazyModule(new ExampleRocketSystem)\n  val dut = Module(ldut.module)\n\n  ldut.io_clocks.get.elements.values.foreach(_.clock := clock)\n  // Allow the debug ndreset to reset the dut, but not until the initial reset has completed\n  val dut_reset = (reset.asBool | ldut.debug.map { debug => AsyncResetReg(debug.ndreset) }.getOrElse(false.B)).asBool\n  ldut.io_clocks.get.elements.values.foreach(_.reset := dut_reset)\n\n  dut.dontTouchPorts()\n  dut.tieOffInterrupts()\n  SimAXIMem.connectMem(ldut)\n  SimAXIMem.connectMMIO(ldut)\n  ldut.l2_frontend_bus_axi4.foreach( a => {\n    a.ar.valid := false.B\n    a.ar.bits := DontCare\n    a.aw.valid := false.B\n    a.aw.bits := DontCare\n    a.w.valid := false.B\n    a.w.bits := DontCare\n    a.r.ready := false.B\n    a.b.ready := false.B\n  })\n  //ldut.l2_frontend_bus_axi4.foreach(_.tieoff)\n  Debug.connectDebug(ldut.debug, ldut.resetctrl, ldut.psd, clock, reset.asBool, io.success)\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "TLBroadcastTracker", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.tilelink", "module": "TLBroadcastTracker", "io": {"inputs": [{"name": "in_a_first", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "probe", "type": "Valid", "chisel_type": "Valid", "width": "new ProbeTrackInfo(caches)"}, {"name": "probenack", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "probedack", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "probesack", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "d_last", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "e_last", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "clearOH", "type": "UInt", "chisel_type": "UInt", "width": "caches.W"}], "outputs": [{"name": "idle", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "need_d", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "cacheOH", "type": "UInt", "chisel_type": "UInt", "width": "caches.W"}]}}}, "output": {"code_after": "class TLBroadcastTracker(id: Int, lineBytes: Int, caches: Int, bufferless: Boolean, edgeIn: TLEdgeIn, edgeOut: TLEdgeOut) extends Module\n{\n  val io = IO(new Bundle {\n    val in_a_first = Input(Bool())\n    val in_a  = Flipped(Decoupled(new TLBundleA(edgeIn.bundle)))\n    val out_a = Decoupled(new TLBundleA(edgeOut.bundle))\n    val probe = Input(Valid(new ProbeTrackInfo(caches)))\n    val probenack = Input(Bool())\n    val probedack = Input(Bool())\n    val probesack = Input(Bool())\n    val d_last = Input(Bool())\n    val e_last = Input(Bool())\n    val source = Output(UInt()) // the source awaiting D response\n    val line = Output(UInt())   // the line waiting for probes\n    val idle = Output(Bool())\n    val need_d = Output(Bool())\n    val cacheOH = Output(UInt(caches.W))\n    val clearOH = Input(UInt(caches.W))\n  })\n\n  val lineShift = log2Ceil(lineBytes)\n  import TLBroadcastConstants._\n\n  // Only one operation can be inflight per line, because we need to be sure\n  // we send the request after all the probes we sent and before all the next probes\n  val got_e   = RegInit(true.B)\n  val sent_d  = RegInit(true.B)\n  val shared  = Reg(Bool())\n  val opcode  = Reg(chiselTypeOf(io.in_a.bits.opcode))\n  val param   = Reg(chiselTypeOf(io.in_a.bits.param))\n  val size    = Reg(chiselTypeOf(io.in_a.bits.size))\n  val source  = Reg(chiselTypeOf(io.in_a.bits.source))\n  val user    = Reg(chiselTypeOf(io.in_a.bits.user))\n  val echo    = Reg(chiselTypeOf(io.in_a.bits.echo))\n  val address = RegInit((id << lineShift).U(io.in_a.bits.address.getWidth.W))\n  val count   = Reg(UInt(log2Ceil(caches+1).W))\n  val cacheOH = Reg(UInt(caches.W))\n  val idle    = got_e && sent_d\n\n  when (io.in_a.fire && io.in_a_first) {\n    assert (idle)\n    sent_d  := false.B\n    shared  := false.B\n    got_e   := io.in_a.bits.opcode =/= TLMessages.AcquireBlock && io.in_a.bits.opcode =/= TLMessages.AcquirePerm\n    opcode  := io.in_a.bits.opcode\n    param   := io.in_a.bits.param\n    size    := io.in_a.bits.size\n    source  := io.in_a.bits.source\n    user   :<= io.in_a.bits.user\n    echo   :<= io.in_a.bits.echo\n    address := io.in_a.bits.address\n    count   := 1.U\n  }\n\n  cacheOH := cacheOH & ~io.clearOH\n  when (io.probe.valid) {\n    count   := io.probe.bits.count\n    cacheOH := io.probe.bits.cacheOH\n  }\n\n  when (io.d_last) {\n    assert (!sent_d)\n    sent_d := true.B\n  }\n  when (io.e_last) {\n    assert (!got_e)\n    got_e := true.B\n  }\n\n  when (io.probenack || io.probedack) {\n    assert (count > 0.U)\n    count := count - Mux(io.probenack && io.probedack, 2.U, 1.U)\n  }\n\n  when (io.probesack) {\n    shared := true.B\n  }\n\n  io.idle := idle\n  io.need_d := !sent_d\n  io.source := source\n  io.line := address >> lineShift\n  io.cacheOH := cacheOH\n\n  val i_data = Wire(Decoupled(new TLBroadcastData(edgeIn.bundle)))\n  val o_data = Queue(i_data, if (bufferless) 1 else (lineBytes / edgeIn.manager.beatBytes), bufferless)\n\n  io.in_a.ready := (idle || !io.in_a_first) && i_data.ready\n  i_data.valid := (idle || !io.in_a_first) && io.in_a.valid\n  i_data.bits.mask := io.in_a.bits.mask\n  i_data.bits.data := io.in_a.bits.data\n\n  val probe_done = count === 0.U\n  val acquire = opcode === TLMessages.AcquireBlock || opcode === TLMessages.AcquirePerm\n\n  val transform = Mux(shared, TRANSFORM_B, TRANSFORM_T)\n\n  o_data.ready := io.out_a.ready && probe_done\n  io.out_a.valid := o_data.valid && probe_done\n  io.out_a.bits.opcode  := Mux(acquire, TLMessages.Get, opcode)\n  io.out_a.bits.param   := Mux(acquire, 0.U, param)\n  io.out_a.bits.size    := size\n  io.out_a.bits.source  := Cat(Mux(acquire, transform, PASS), source)\n  io.out_a.bits.address := address\n  io.out_a.bits.mask    := o_data.bits.mask\n  io.out_a.bits.data    := o_data.bits.data\n  io.out_a.bits.corrupt := false.B\n  io.out_a.bits.user   :<= user\n  io.out_a.bits.echo   :<= echo\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "LevelGateway", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.devices.tilelink", "module": "LevelGateway", "io": {"inputs": [{"name": "interrupt", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": []}}}, "output": {"code_after": "class LevelGateway extends Module {\n  val io = IO(new Bundle {\n    val interrupt = Input(Bool())\n    val plic = new GatewayPLICIO\n  })\n\n  val inFlight = RegInit(false.B)\n  when (io.interrupt && io.plic.ready) { inFlight := true.B }\n  when (io.plic.complete) { inFlight := false.B }\n  io.plic.valid := io.interrupt && !inFlight\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "TagMan", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.groundtest", "module": "TagMan", "io": {"inputs": [{"name": "take", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "put", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "tagIn", "type": "UInt", "chisel_type": "UInt", "width": "(logNumTags.W)"}], "outputs": [{"name": "available", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "tagOut", "type": "UInt", "chisel_type": "UInt", "width": "logNumTags.W"}]}}}, "output": {"code_after": "class TagMan(val logNumTags : Int) extends Module {\n  val io = IO(new Bundle {\n    // Is there a tag available?\n    val available = Output(Bool())\n    // If so, which one?\n    val tagOut    = Output(UInt(logNumTags.W))\n    // User pulses this to take the currently available tag\n    val take      = Input(Bool())\n    // User pulses this to put a tag back\n    val put       = Input(Bool())\n    // And the tag put back is\n    val tagIn     = Input(UInt((logNumTags.W)))\n  })\n\n  // Total number of tags available\n  val numTags = 1 << logNumTags\n\n  // For each tag, record whether or not it is in use\n  val inUse = List.fill(numTags)(RegInit(false.B))\n\n  // Mapping from each tag to its 'inUse' bit\n  val inUseMap = (0 to numTags-1).map(i => i.U).zip(inUse)\n\n  // Next tag to offer\n  val nextTag = RegInit(0.U(logNumTags.W))\n  io.tagOut := nextTag\n\n  // Is the next tag available?\n  io.available := ~MuxLookup(nextTag, true.B)(inUseMap)\n\n  // When user takes a tag\n  when (io.take) {\n    for ((i, b) <- inUseMap) {\n      when (i === nextTag) { b := true.B }\n    }\n    nextTag := nextTag + 1.U\n  }\n\n  // When user puts a tag back\n  when (io.put) {\n    for ((i, b) <- inUseMap) {\n      when (i === io.tagIn) { b := false.B }\n    }\n  }\n}"}}
{"source": "github_chisel", "task": "impl_from_spec", "operator": "TraceGenerator", "input": {"prompt": "", "code_before": "", "error_log": "", "spec": {"package": "freechips.rocketchip.groundtest", "module": "TraceGenerator", "io": {"inputs": [{"name": "hartid", "type": "UInt", "chisel_type": "UInt", "width": "log2Up(numGens).W"}, {"name": "fence_rdy", "type": "Bool", "chisel_type": "Bool", "width": "1"}], "outputs": [{"name": "finished", "type": "Bool", "chisel_type": "Bool", "width": "1"}, {"name": "timeout", "type": "Bool", "chisel_type": "Bool", "width": "1"}]}}}, "output": {"code_after": "class TraceGenerator(val params: TraceGenParams)(implicit val p: Parameters) extends Module\n    with HasTraceGenParams {\n  val io = IO(new Bundle {\n    val finished = Output(Bool())\n    val timeout = Output(Bool())\n    val mem = new HellaCacheIO\n    val hartid = Input(UInt(log2Up(numGens).W))\n    val fence_rdy = Input(Bool())\n  })\n\n  val totalNumAddrs = addressBag.size + numExtraAddrs\n  val initCount = RegInit(0.U(log2Up(totalNumAddrs).W))\n  val initDone  = RegInit(false.B)\n\n  val reqTimer = Module(new Timer(8192, maxTags))\n  reqTimer.io.start.valid := io.mem.req.fire\n  reqTimer.io.start.bits := io.mem.req.bits.tag\n  reqTimer.io.stop.valid := io.mem.resp.valid\n  reqTimer.io.stop.bits := io.mem.resp.bits.tag\n\n  // Random addresses\n  // ----------------\n\n  // Address bag, shared by all cores, taken from module parameters.\n  // In addition, there is a per-core random selection of extra addresses.\n\n  val bagOfAddrs = addressBag.map(x => (memStart + x).U(pAddrBits.W))\n\n  val extraAddrs = Seq.fill(numExtraAddrs) {\n    (memStart + SeededRandom.fromSeed.nextInt(1 << 16) * numBytesInWord).U(pAddrBits.W)\n  }\n\n  // A random index into the address bag.\n\n  val randAddrBagIndex = LCG(logAddressBagLen)\n\n  // A random address from the address bag.\n\n  val addrBagIndices = (0 to addressBagLen-1).\n                    map(i => i.U(logAddressBagLen.W))\n\n  val randAddrFromBag = MuxLookup(randAddrBagIndex, 0.U)(\n                          addrBagIndices.zip(bagOfAddrs))\n\n  // Random address from the address bag or the extra addresses.\n\n  val extraAddrIndices = (0 to numExtraAddrs-1)\n                          .map(i => i.U(logNumExtraAddrs.W))\n\n  val randAddr =\n        if (! genExtraAddrs) {\n          randAddrFromBag\n        }\n        else {\n          // A random index into the extra addresses.\n\n          val randExtraAddrIndex = LCG(logNumExtraAddrs)\n\n          // A random address from the extra addresses.\n          val randAddrFromExtra = Cat(0.U,\n                MuxLookup(randExtraAddrIndex, 0.U)(\n                  extraAddrIndices.zip(extraAddrs)), 0.U(3.W))\n\n          Frequency(List(\n            (1, randAddrFromBag),\n            (1, randAddrFromExtra)))\n        }\n\n  val allAddrs = extraAddrs ++ bagOfAddrs\n  val allAddrIndices = (0 until totalNumAddrs)\n    .map(i => i.U(log2Ceil(totalNumAddrs).W))\n  val initAddr = MuxLookup(initCount, 0.U)(\n    allAddrIndices.zip(allAddrs))\n\n  // Random opcodes\n  // --------------\n\n  // Generate random opcodes for memory operations according to the\n  // given frequency distribution.\n\n  // Opcodes\n  val (opNop   :: opLoad :: opStore ::\n       opFence :: opLRSC :: opSwap  ::\n       opDelay :: Nil) = Enum(7)\n\n  // Distribution specified as a list of (frequency,value) pairs.\n  // NOTE: frequencies must sum to a power of two.\n\n  val randOp = Frequency(List(\n    (10, opLoad),\n    (10, opStore),\n    (4,  opFence),\n    (3,  opLRSC),\n    (3,  opSwap),\n    (2,  opDelay)))\n\n  // Request/response tags\n  // ---------------------\n\n  // Responses may come back out-of-order.  Each request and response\n  // therefore contains a unique 7-bit identifier, referred to as a\n  // \"tag\", used to match each response with its corresponding request.\n\n  // Create a tag manager giving out unique 3-bit tags\n  val tagMan = Module(new TagMan(log2Ceil(maxTags)))\n\n  // Default inputs\n  tagMan.io.take  := false.B;\n  tagMan.io.put   := false.B;\n  tagMan.io.tagIn := 0.U;\n\n  // Cycle counter\n  // -------------\n\n  // 32-bit cycle count used to record send-times of requests and\n  // receive-times of respones.\n\n  val cycleCount = RegInit(0.U(32.W))\n  cycleCount := cycleCount + 1.U;\n\n  // Delay timer\n  // -----------\n\n  // Used to implement the delay operation and to insert random\n  // delays between load-reserve and store-conditional commands.\n\n  // A 16-bit timer is plenty\n  val delayTimer = Module(new DynamicTimer(16))\n\n  // Used to generate a random delay period\n  val randDelayBase = LCG16()\n\n  // Random delay period: usually small, occasionally big\n  val randDelay = Frequency(List(\n    (14, 0.U(13.W) ## randDelayBase(2, 0)),\n    (2,  0.U(11.W) ## randDelayBase(5, 0))))\n\n  // Default inputs\n  delayTimer.io.start  := false.B\n  delayTimer.io.period := randDelay\n  delayTimer.io.stop   := false.B\n\n  // Operation dispatch\n  // ------------------\n\n  // Hardware thread id\n  val tid = io.hartid\n\n  // Request & response count\n  val reqCount  = RegInit(0.U(32.W))\n  val respCount = RegInit(0.U(32.W))\n\n  // Current operation being executed\n  val currentOp = RegInit(opNop)\n\n  // If larger than 0, a multi-cycle operation is in progress.\n  // Value indicates stage of progress.\n  val opInProgress = RegInit(0.U(2.W))\n\n  // Indicate when a fresh request is to be sent\n  val sendFreshReq = Wire(Bool())\n  sendFreshReq := false.B\n\n  // Used to generate unique data values\n  val nextData = RegInit(1.U((numBitsInWord-tid.getWidth).W))\n\n  // Registers for all the interesting parts of a request\n  val reqValid = RegInit(false.B)\n  val reqAddr  = RegInit(0.U(numBitsInWord.W))\n  val reqData  = RegInit(0.U(numBitsInWord.W))\n  val reqCmd   = RegInit(0.U(5.W))\n  val reqTag   = RegInit(0.U(7.W))\n\n   // Condition on being allowed to send a fresh request\n  val canSendFreshReq = (!reqValid || io.mem.req.fire) &&\n                          tagMan.io.available\n\n  // Operation dispatch\n  when (reqCount < numReqsPerGen.U) {\n\n    // No-op\n    when (currentOp === opNop) {\n      // Move on to a new operation\n      currentOp := Mux(initDone, randOp, opStore)\n    }\n\n    // Fence\n    when (currentOp === opFence) {\n      when (opInProgress === 0.U && !reqValid) {\n        // Emit fence request\n        printf(\"%d: fence-req @%d\\n\", tid, cycleCount)\n        // Multi-cycle operation now in progress\n        opInProgress := 1.U\n      }\n      // Wait until all requests have had a response\n      .elsewhen (reqCount === respCount && io.fence_rdy) {\n        // Emit fence response\n        printf(\"%d: fence-resp @%d\\n\", tid, cycleCount)\n        // Move on to a new operation\n        currentOp := randOp\n        // Operation finished\n        opInProgress := 0.U\n      }\n    }\n\n    // Delay\n    when (currentOp === opDelay) {\n      when (opInProgress === 0.U) {\n        // Start timer\n        delayTimer.io.start := true.B\n        // Multi-cycle operation now in progress\n        opInProgress := 1.U\n      }\n      .elsewhen (delayTimer.io.timeout) {\n        // Move on to a new operation\n        currentOp := randOp\n        // Operation finished\n        opInProgress := 0.U\n      }\n    }\n\n    // Load, store, or atomic swap\n    when (currentOp === opLoad  ||\n          currentOp === opStore ||\n          currentOp === opSwap) {\n      when (canSendFreshReq) {\n        // Set address\n        reqAddr := Mux(initDone, randAddr, initAddr)\n        // Set command\n        when (currentOp === opLoad) {\n          reqCmd := M_XRD\n        } .elsewhen (currentOp === opStore) {\n          reqCmd := M_XWR\n        } .elsewhen (currentOp === opSwap) {\n          reqCmd := M_XA_SWAP\n        }\n        // Send request\n        sendFreshReq := true.B\n        // Move on to a new operation\n        when (!initDone && initCount =/= (totalNumAddrs - 1).U) {\n          initCount := initCount + 1.U\n          currentOp := opStore\n        } .otherwise {\n          currentOp := randOp\n          initDone := true.B\n        }\n      }\n    }\n\n    // Load-reserve and store-conditional\n    // First issue an LR, then delay, then issue an SC\n    when (currentOp === opLRSC) {\n      // LR request has not yet been sent\n      when (opInProgress === 0.U) {\n        when (canSendFreshReq) {\n          // Set address and command\n          reqAddr := randAddr\n          reqCmd  := M_XLR\n          // Send request\n          sendFreshReq := true.B\n          // Multi-cycle operation now in progress\n          opInProgress := 1.U\n        }\n      }\n      // LR request has been sent, start delay timer\n      when (opInProgress === 1.U) {\n        // Start timer\n        delayTimer.io.start := true.B\n        // Indicate that delay has started\n        opInProgress := 2.U\n      }\n      // Delay in progress\n      when (opInProgress === 2.U) {\n        when (delayTimer.io.timeout) {\n          // Delay finished\n          opInProgress := 3.U\n        }\n      }\n      // Delay finished, send SC request\n      when (opInProgress === 3.U) {\n        when (canSendFreshReq) {\n          // Set command, but leave address\n          // i.e. use same address as LR did\n          reqCmd  := M_XSC\n          // Send request\n          sendFreshReq := true.B\n          // Multi-cycle operation finished\n          opInProgress := 0.U\n          // Move on to a new operation\n          currentOp := randOp\n        }\n      }\n    }\n  }\n\n  // Sending of requests\n  // -------------------\n\n  when (sendFreshReq) {\n    // Grab a unique tag for the request\n    reqTag := tagMan.io.tagOut\n    tagMan.io.take := true.B\n    // Fill in unique data\n    reqData := Cat(nextData, tid)\n    nextData := nextData + 1.U\n    // Request is good to go!\n    reqValid := true.B\n    // Increment request count\n    reqCount := reqCount + 1.U\n  }\n  .elsewhen (io.mem.req.fire) {\n    // Request has been sent and there is no new request ready\n    reqValid := false.B\n  }\n\n  // Wire up interface to memory\n  io.mem.req.valid     := reqValid\n  io.mem.req.bits.addr := reqAddr\n  io.mem.req.bits.data := reqData\n  io.mem.req.bits.size := log2Ceil(numBytesInWord).U\n  io.mem.req.bits.signed := false.B\n  io.mem.req.bits.cmd  := reqCmd\n  io.mem.req.bits.tag  := reqTag\n  io.mem.req.bits.no_alloc := false.B\n  io.mem.req.bits.no_xcpt := false.B\n  io.mem.req.bits.no_resp := false.B\n  io.mem.req.bits.mask := ~(0.U((numBitsInWord / 8).W))\n  io.mem.req.bits.phys := false.B\n  io.mem.req.bits.dprv := PRV.M.U\n  io.mem.req.bits.dv := false.B\n  io.mem.keep_clock_enabled := true.B\n\n  // The below signals don't matter because this uses the SimpleHellaIF\n  io.mem.s1_data.data := RegNext(io.mem.req.bits.data)\n  io.mem.s1_data.mask := RegNext(io.mem.req.bits.mask)\n  io.mem.s1_kill := false.B\n  io.mem.s2_kill := false.B\n\n  // On cycle when request is actually sent, print it\n  when (io.mem.req.fire) {\n    // Short-hand for address\n    val addr = io.mem.req.bits.addr\n    // Print thread id\n    printf(\"%d:\", tid)\n    // Print command\n    when (reqCmd === M_XRD) {\n      printf(\" load-req 0x%x\", addr)\n    }\n    when (reqCmd === M_XLR) {\n      printf(\" load-reserve-req 0x%x\", addr)\n    }\n    when (reqCmd === M_XWR) {\n      printf(\" store-req %d 0x%x\", reqData, addr)\n    }\n    when (reqCmd === M_XSC) {\n      printf(\" store-cond-req %d 0x%x\", reqData, addr)\n    }\n    when (reqCmd === M_XA_SWAP) {\n      printf(\" swap-req %d 0x%x\", reqData, addr)\n    }\n    // Print tag\n    printf(\" #%d\", reqTag)\n    // Print time\n    printf(\" @%d\\n\", cycleCount)\n  }\n\n  // Handling of responses\n  // ---------------------\n\n  // When a response is received\n  when (io.mem.resp.valid) {\n    // Put tag back in tag set\n    tagMan.io.tagIn := io.mem.resp.bits.tag\n    tagMan.io.put   := true.B\n    // Print response\n    printf(\"%d: resp %d #%d @%d\\n\", tid,\n      io.mem.resp.bits.data, io.mem.resp.bits.tag, cycleCount)\n    // Increment response count\n    respCount := respCount + 1.U\n  }\n\n  // Termination condition\n  // ---------------------\n\n  val done = reqCount  === numReqsPerGen.U &&\n             respCount === numReqsPerGen.U\n\n  val donePulse = done && !RegNext(done, false.B)\n\n  // Emit that this thread has completed\n  when (donePulse) {\n    printf(s\"FINISHED ${numGens}\\n\")\n  }\n\n  io.finished := done\n  io.timeout := reqTimer.io.timeout.valid\n}"}}
