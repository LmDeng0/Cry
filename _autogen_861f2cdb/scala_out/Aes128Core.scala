// AUTO-GENERATED by codegen_from_plan.py — DO NOT EDIT MANUALLY
// Source plan: spec/aes128_auto.yaml

package crypto.gen

import chisel3._
import chisel3.util._
import crypto.common._
import crypto.aes._


/** Auto-generated top from plan: Aes128Core (algo=AES) */
class Aes128Core(p: CryptoParams = CryptoParams()) extends Module {
  val io = IO(new CryptoIO(p))

  // KeySchedule（占位：使用现有 KeySchedule，占位实现会把同一把 key 复制到所有轮）
  val ks   = Module(new KeySchedule(p, rounds = 10))
  ks.io.keyIn.bits := io.key.bits

  // InitRound: AddRoundKey(in, rk0)
  val init = Module(new AddRoundKey(p))
  init.io.rk.bits := ks.io.rks(0).bits
  init.io.in <> io.in

  // Round1..RoundN-1: Std rounds
    val r1 = Module(new AesStdRound(p))
  r1.io.rk.bits := ks.io.rks(1).bits
  r1.io.in <> init.io.out
  val r2 = Module(new AesStdRound(p))
  r2.io.rk.bits := ks.io.rks(2).bits
  r2.io.in <> r1.io.out
  val r3 = Module(new AesStdRound(p))
  r3.io.rk.bits := ks.io.rks(3).bits
  r3.io.in <> r2.io.out
  val r4 = Module(new AesStdRound(p))
  r4.io.rk.bits := ks.io.rks(4).bits
  r4.io.in <> r3.io.out
  val r5 = Module(new AesStdRound(p))
  r5.io.rk.bits := ks.io.rks(5).bits
  r5.io.in <> r4.io.out
  val r6 = Module(new AesStdRound(p))
  r6.io.rk.bits := ks.io.rks(6).bits
  r6.io.in <> r5.io.out
  val r7 = Module(new AesStdRound(p))
  r7.io.rk.bits := ks.io.rks(7).bits
  r7.io.in <> r6.io.out
  val r8 = Module(new AesStdRound(p))
  r8.io.rk.bits := ks.io.rks(8).bits
  r8.io.in <> r7.io.out
  val r9 = Module(new AesStdRound(p))
  r9.io.rk.bits := ks.io.rks(9).bits
  r9.io.in <> r8.io.out


  // FinalRound: no MixColumns
  val finalR = Module(new AesFinalRound(p))
  finalR.io.rk.bits := ks.io.rks(10).bits
  finalR.io.in <> r9.io.out

  // 输出
  io.out <> finalR.io.out

  // 一点点保护性断言（占位）
  when (io.in.valid && !io.in.ready) {
    assert(!io.out.valid, "Backpressure hazard")
  }
}
