# generator/codegen_from_plan.py
import argparse, os, yaml, textwrap, pathlib

HEADER = """\
// AUTO-GENERATED by codegen_from_plan.py — DO NOT EDIT MANUALLY
// Source plan: {plan_path}
"""

PKG_GEN = "package crypto.gen\n"
IMPORTS = """\
import chisel3._
import chisel3.util._
import crypto.common._
import crypto.aes._
"""

TOP_TMPL = """\
{header}
{pkg}
{imports}

/** Auto-generated top from plan: {top_name} (algo={algo}) */
class {top_name}(p: CryptoParams = CryptoParams()) extends Module {{
  val io = IO(new CryptoIO(p))

  // KeySchedule（占位：使用现有 KeySchedule，占位实现会把同一把 key 复制到所有轮）
  val ks   = Module(new KeySchedule(p, rounds = {rounds}))
  ks.io.keyIn.bits := io.key.bits

  // InitRound: AddRoundKey(in, rk0)
  val init = Module(new AddRoundKey(p))
  init.io.rk.bits := ks.io.rks(0).bits
  init.io.in <> io.in

  // Round1..RoundN-1: Std rounds
  {std_round_wires}

  // FinalRound: no MixColumns
  val finalR = Module(new AesFinalRound(p))
  finalR.io.rk.bits := ks.io.rks({rounds}).bits
  finalR.io.in <> {last_std_out}

  // 输出
  io.out <> finalR.io.out

  // 一点点保护性断言（占位）
  when (io.in.valid && !io.in.ready) {{
    assert(!io.out.valid, "Backpressure hazard")
  }}
}}
"""

STD_ROUND_LINE = """\
  val r{idx} = Module(new AesStdRound(p))
  r{idx}.io.rk.bits := ks.io.rks({rk_idx}).bits
  {in_expr}
"""

# 骨架模板：若 plan 中出现了某些“未知 kind”的节点，就给出最小直通模板
NODE_TMPLS = {
    "KeySchedule": """\
{header}
{pkg}
{imports}
/** Placeholder KeySchedule (auto-generated). Prefer using crypto.aes.KeySchedule. */
class KeyScheduleGen(p: CryptoParams, rounds: Int) extends Module {{
  val io = IO(new Bundle {{
    val keyIn = Input(new Key(p))
    val rks   = Output(Vec(rounds+1, new Key(p)))
  }})
  for (i <- 0 to rounds) {{ io.rks(i).bits := io.keyIn.bits }}
}}
""",
    "AddRoundKey": """\
{header}
{pkg}
{imports}
/** Placeholder AddRoundKey (auto-generated). Prefer using crypto.aes.AddRoundKey. */
class AddRoundKeyGen(p: CryptoParams) extends Module {{
  val io = IO(new Bundle {{
    val in  = Flipped(Decoupled(new Block(p)))
    val rk  = Input(new Key(p))
    val out = Decoupled(new Block(p))
  }})
  io.out.valid := io.in.valid
  io.in.ready  := io.out.ready
  io.out.bits.bits := io.in.bits.bits ^ io.rk.bits
}}
""",
    "StdRound": """\
{header}
{pkg}
{imports}
/** Placeholder StdRound (auto-generated). Prefer using crypto.aes.AesStdRound. */
class StdRoundGen(p: CryptoParams) extends Module {{
  val io = IO(new Bundle {{
    val in  = Flipped(Decoupled(new Block(p)))
    val rk  = Input(new Key(p))
    val out = Decoupled(new Block(p))
  }})
  val core = Module(new AesStdRound(p))
  core.io.in <> io.in
  core.io.rk := io.rk
  io.out <> core.io.out
}}
""",
    "FinalRound": """\
{header}
{pkg}
{imports}
/** Placeholder FinalRound (auto-generated). Prefer using crypto.aes.AesFinalRound. */
class FinalRoundGen(p: CryptoParams) extends Module {{
  val io = IO(new Bundle {{
    val in  = Flipped(Decoupled(new Block(p)))
    val rk  = Input(new Key(p))
    val out = Decoupled(new Block(p))
  }})
  val core = Module(new AesFinalRound(p))
  core.io.in <> io.in
  core.io.rk := io.rk
  io.out <> core.io.out
}}
"""
}

def load_plan(plan_path: str) -> dict:
    with open(plan_path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)

def ensure_dir(path: str):
    pathlib.Path(path).mkdir(parents=True, exist_ok=True)

def gen_top(plan: dict, out_dir: str, plan_path: str):
    top = plan.get("top", "CryptoTop")
    algo = plan.get("algo", "AES")
    params = plan.get("params", {})
    rounds = int(params.get("ROUNDS", 10))

    # 生成 std rounds 连接片段
    std_wire_lines = []
    # 首个 std round 的输入来自 init.out
    in_expr = "r1.io.in <> init.io.out"
    if rounds > 1:
        for i in range(1, rounds):  # 1..(ROUNDS-1)
            rk_idx = i  # rk1..rk(ROUNDS-1)
            prev = "init.io.out" if i == 1 else f"r{i-1}.io.out"
            in_expr_line = f"r{i}.io.in <> {prev}"
            std_wire_lines.append(STD_ROUND_LINE.format(idx=i, rk_idx=rk_idx, in_expr=in_expr_line))
        last_std_out = f"r{rounds-1}.io.out" if rounds > 1 else "init.io.out"
    else:
        last_std_out = "init.io.out"

    body = TOP_TMPL.format(
        header=HEADER.format(plan_path=plan_path),
        pkg=PKG_GEN,
        imports=IMPORTS,
        top_name=top,
        algo=algo,
        rounds=rounds,
        std_round_wires="".join(std_wire_lines),
        last_std_out=last_std_out
    )

    out_file = os.path.join(out_dir, f"{top}.scala")
    with open(out_file, "w", encoding="utf-8") as f:
        f.write(body)
    print(f"[gen] {out_file}")

def gen_node_placeholders(plan: dict, out_dir: str, plan_path: str):
    """按 dag 中的 kind 生成必要的占位类（仅当需要时）"""
    kinds = set()
    for n in plan.get("dag", []):
        k = n.get("kind")
        if k: kinds.add(k)

    for k in sorted(kinds):
        if k in NODE_TMPLS:
            code = NODE_TMPLS[k].format(
                header=HEADER.format(plan_path=plan_path),
                pkg=PKG_GEN,
                imports=IMPORTS
            )
            filename = os.path.join(out_dir, f"{k}Gen.scala")
            with open(filename, "w", encoding="utf-8") as f:
                f.write(code)
            print(f"[gen] {filename}")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--plan", required=True)
    ap.add_argument("--out",  required=True)
    args = ap.parse_args()

    plan = load_plan(args.plan)
    ensure_dir(args.out)

    # 1) 生成顶层（占位装配，依赖 crypto.aes 中已有的子模块）
    gen_top(plan, args.out, args.plan)

    # 2) 根据 dag 的 kind 生成占位节点（如果遇到未知 kind，也能提供骨架）
    gen_node_placeholders(plan, args.out, args.plan)

    print("[ok] codegen completed.")

if __name__ == "__main__":
    main()

