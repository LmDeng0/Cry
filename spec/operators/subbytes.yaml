version: 0.1

operator:
  name: SubBytes
  module_name: SubBytesLLMAuto
  package: crypto.aes.llm.auto
  category: aes
  description: >
    AES-128 SubBytes transformation.
    Input/output are 128-bit AES state values, little-endian byte order
    (byte 0 = lowest 8 bits), matching existing SubBytesLLMSpec tests.

  io:
    clock: implicit
    reset: implicit
    inputs:
      - name: state_in
        width: 128
        signed: false
    outputs:
      - name: state_out
        width: 128
        signed: false

  timing:
    combinational: true
    latency_cycles: 0

  behavior:
    kind: stateless_pure
    aes_state_layout: little_endian_bytes
    description: |
      For each byte of the 128-bit state (byte 0 = LSB),
      apply AES S-Box lookup.
    pseudocode: |
      for i in 0..15:
        out[i] = SBOX[in[i]]

llm:
  extra_imports:
    - crypto.aes.AesSBoxConst

  implementation_hint: |
    IMPORTANT (your output must follow existing tests):
      - AES state is interpreted LITTLE-ENDIAN:
          Byte 0 is bits [7:0], byte 15 is [127:120]
      - Therefore DO NOT reverse output bytes.

      1. Convert S-Box table (Seq[Int]) to Vec[UInt(8.W)]:
           val sbox = VecInit(AesSBoxConst.table.map(_.U(8.W)))

      2. Extract 16 bytes:
           val inBytes = Wire(Vec(16, UInt(8.W)))
           for (i <- 0 until 16) {
             inBytes(i) := io.state_in(8*(i+1)-1, 8*i)
           }

      3. S-Box lookup:
           val outBytes = Wire(Vec(16, UInt(8.W)))
           for (i <- 0 until 16) {
             outBytes(i) := sbox(inBytes(i))
           }

      4. Assemble output (NO reverse):
           io.state_out := Cat(outBytes)

    STRICT RULES:
      - ONLY use UInt.
      - DO NOT use Bits(), SInt(), Signed().
      - DO NOT use asTypeOf(Vec(...)).
      - DO NOT define SBOX manually.
      - ALWAYS use AesSBoxConst.table.

test:
  test_cmd: "testOnly"
  suite_name: "crypto.aes.llm.auto.SubBytesAutoSpec"
