version: 1.0

operator:
  name: SubBytes
  module_name: SubBytesLLMAuto
  ref_name: SubBytesRef          # 软件模型类名
  spec_name: SubBytesAutoSpec    # 自动测试类名
  package: crypto.aes.llm.auto
  category: aes

  description: |
    AES-128 SubBytes transformation.
    The operator applies the AES S-Box to each of the 16 bytes
    of the 128-bit state. State layout follows FIPS-197.

  io:
    inputs:
      - { name: state_in,  width: 128 }
    outputs:
      - { name: state_out, width: 128 }

behavior:
  kind: stateless_pure
  aes_state_layout: column_major
  constraints: |
    - Pure combinational logic.
    - No registers.
    - Each byte is substituted independently:
         state_out[i] = AES_SBOX[state_in[i]]

llm:
  generate_ref_model: true        # 生成软件参考模型
  generate_testbench: true        # 生成 test spec
  extra_imports:
    - crypto.aes.AesSBoxConst

  module_hint: |
    - Convert AesSBoxConst.table (Seq[Int]) into Vec[UInt(8.W)] via:
         val sbox = VecInit(AesSBoxConst.table.map(_.U(8.W)))
    - Extract 16 bytes using bit slicing.
    - Use only UInt, no SInt/Bits/Signed.
    - io.state_out = Cat(outBytes.reverse)

  ref_hint: |
    Implement SubBytes in pure Scala:
      - state represented as BigInt.
      - Extract 16 input bytes.
      - For each byte: out[i] = aes_sbox_table(in[i]).
      - Return BigInt assembled from substituted bytes.

  test_hint: |
    - Instantiate SubBytesLLMAuto.
    - For each test vector:
        expected = SubBytesRef(in)
        dut.io.state_in.poke(in.U)
        step(1)
        dut.io.state_out.expect(expected.U)
    - Use 3 fixed AES vectors
    - Add 20 random vectors

test:
  test_cmd: "testOnly"
  suite_name: "crypto.aes.llm.auto.SubBytesAutoSpec"

dataset:
  save: true
  path: datasets/op_level/subbytes
